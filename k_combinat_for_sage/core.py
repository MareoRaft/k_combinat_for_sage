r"""
A place for things that may be useful in core sage (not specific to k-combinatorics)
"""
from sage.all import *


def summands(poly):
	r""" Iterate through the summands of a symmetric function.

	For example, ``(s[2, 1] + s[3])`` has summands ``s[2, 1]`` and ``s[3]``.
	"""
	parent_basis = poly.parent()
	return (coeff * parent_basis(index) for index, coeff in poly)

def prod(lis):
	return reduce(operator.mul, lis, 1)


class InfiniteDimensionalFreeAlgebra(CombinatorialFreeModule):
    r"""
    By default, the algebra generated by ``x[0], x[1], x[2], ...`` over the integers.

    To change the index set of the generators, use ``index_set=`` (default ``NN``).  To overhaul the set of generators entirely (not recommended), use ``basis_indices=``.

    To change the ring that the algebra works over, use ``base_ring=`` (default ``ZZ``).

    To change the prefix of the generators, use ``prefix=`` (default ``'x'``).
    """
    def __init__(self,
            base_ring=IntegerRing(),
            prefix='x',
            basis_indices=None,
            index_set=NonNegativeIntegerSemiring()):
        self._base_ring = base_ring
        self._basis_monoid = FreeMonoid(index_set=index_set, commutative=True, prefix=prefix) if basis_indices is None else basis_indices
        # category
        category = Algebras(self._base_ring.category()).WithBasis().Commutative()
        category = category.or_subcategory(category)
        # init
        CombinatorialFreeModule.__init__(
            self,
            self._base_ring,
            self._basis_monoid,
            category=category,
            prefix='',
            bracket=False)
        # TODO: make a SEPARATE class called InfiniteDimensionalFreeRing or similar
        # self._init_category_(CommutativeRings()) # i think .Commutative() above is a better solution

    def is_prime_field(self):
    	return False

    def _element_constructor_(self, monoid_el):
        assert monoid_el in self._basis_monoid
        return self.basis()[monoid_el]

    def __getitem__(self, user_input):
        # USER front entrance to creating elements "x[4]"
        assert user_input in IntegerRing()
        monoid_el = self._basis_monoid.gen(user_input)
        return self.basis()[monoid_el]

    @cached_method
    def one_basis(self):
        # identity index
        return self._basis_monoid.one()

    def product_on_basis(self, monoid_el1, monoid_el2):
        monoid_el_product = monoid_el1 * monoid_el2
        return self._element_constructor_(monoid_el_product)

    def _repr_(self):
        return "{class_name} with generators indexed by integers, over {base_ring}".format(class_name=self.__class__.__name__, base_ring=self._base_ring)


# class InfiniteDimensionalFreeRing (CommutativeRing, InfiniteDimensionalFreeAlgebra):
# 	pass

# base_ring=IntegerRing()
# algebras = Algebras(base_ring.category()).WithBasis()
# commutative_rings = CommutativeRings()
# F = ForgetfulFunctor(algebras, commutative_rings)
# InfiniteDimensionalFreeRing = F(InfiniteDimensionalFreeAlgebra)

# idea: coerce

# idea: manually change the category
# found '_init_category_' '_initial_coerce_list' '_initial_convert_list' '_unset_category' 'category' 'categories' 'coerce' 'hom' 'is_ring'

# Let us declare a coercion from `\ZZ[x]` to `\ZZ[z]`::
#  |
#  |                  sage: Z.<z> = ZZ[]
#  |                  sage: phi = Hom(X, Z)(z)
#  |                  sage: phi(x^2+1)
#  |                  z^2 + 1
#  |                  sage: phi.register_as_coercion()
#  |
#  |              Now we can add elements from `\ZZ[x]` and `\ZZ[z]`, because
#  |              the elements of the former are allowed to be implicitly
#  |              coerced into the later::
#  |
#  |                  sage: x^2 + z
#  |                  z^2 + z

# idea: patch SymmetricFunctions to accept Algebras, not just 'commutative rings'
