
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>root_ideal &#8212; k-Schur combinatorics for SageMath 0.1.4 documentation</title>
    <link rel="stylesheet" href="../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="icon" href="../_static/sageicon.png" type="image/x-icon" />
    <script src="../_static/thebe.js" type="text/javascript"></script>
    <script src="../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  
    
      <a href="../../index.html"><img src="../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../index.html">k-Schur combinatorics for SageMath 0.1.4 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for root_ideal</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sage does *not* have a builtin &#39;RootIdeal&#39; object.  *This* module contains a RootIdeal class and useful functions pertaining to root ideals:</span>

<span class="sd">AUTHORS:</span>

<span class="sd">- Matthew Lancellotti (2018): Initial version</span>

<span class="sd">REFERENCES:</span>

<span class="sd">.. [cat] `Catalan functions and k-schur positivity &lt;https://arxiv.org/abs/1804.03701&gt;`_</span>
<span class="sd">.. [scat] Skew-linked Catalan functions and k-schur positivity.  Jonah Blasiak, Jennifer Morse, Anna Pun, and Daniel Summers.  Not to be confused with &#39;Catalan functions and k-schur positivity.&#39;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#*****************************************************************************</span>
<span class="c1">#  Copyright (C) 2018 Matthew Lancellotti &lt;mvlancellotti@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#                  http://www.gnu.org/licenses/</span>
<span class="c1">#*****************************************************************************</span>

<span class="kn">from</span> <span class="nn">sage.all</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">partition</span>
<span class="kn">import</span> <span class="nn">skew_partition</span>
<span class="n">SetPartitionsAk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsBk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsIk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsPRk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsPk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsRk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsSk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsTk</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># HELPERS</span>


<div class="viewcode-block" id="is_pseudo_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.is_pseudo_partition">[docs]</a><span class="k">def</span> <span class="nf">is_pseudo_partition</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return whether ``seq`` is a pseudo-partition.</span>

<span class="sd">    A __pseudo partition__ is a composition `\gamma` such that `\gamma + \rho` is a partition, where `\rho` is the staircase shape.</span>

<span class="sd">    Another way to think of this function is that it will return ``False`` if the &quot;slope&quot; ever exceeds `+1`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: is_pseudo_partition([5, 3, 1])</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_pseudo_partition([3, 2, 1])</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_pseudo_partition([2, 2, 2])</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_pseudo_partition([1, 2, 3])</span>
<span class="sd">        True</span>
<span class="sd">        sage: is_pseudo_partition([1, 3, 5])</span>
<span class="sd">        False</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`staircase_shape`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: test</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">term</span> <span class="ow">in</span> <span class="n">IntegerRing</span><span class="p">()</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<span class="k">def</span> <span class="nf">_generate_path</span><span class="p">(</span><span class="n">next_func</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the list generated by ``start`` by applying ``next_func`` to it repeatedly until reading ``None``.</span>

<span class="sd">    A helper function.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: def fun(x):</span>
<span class="sd">        ....:     if x == 4:</span>
<span class="sd">        ....:         return None</span>
<span class="sd">        ....:     else:</span>
<span class="sd">        ....:         return x + 1</span>
<span class="sd">        ....:</span>
<span class="sd">        sage: _generate_path(fun, -2)</span>
<span class="sd">        [-2, -1, 0, 1, 2, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="n">next_func</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">next_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">path</span>


<div class="viewcode-block" id="staircase_shape"><a class="viewcode-back" href="../root_ideal.html#root_ideal.staircase_shape">[docs]</a><span class="k">def</span> <span class="nf">staircase_shape</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given ``n``, return the composition `[n-1, n-2, \ldots, 0]` commonly denoted `\rho`.</span>

<span class="sd">    Yes, this INCLUDES a 0 at the end!</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: staircase_shape(3)</span>
<span class="sd">        [2, 1, 0]</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`RootIdeals.init_staircase`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Composition</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="skew_partition_to_selected_rows"><a class="viewcode-back" href="../root_ideal.html#root_ideal.skew_partition_to_selected_rows">[docs]</a><span class="k">def</span> <span class="nf">skew_partition_to_selected_rows</span><span class="p">(</span><span class="n">sp</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a skew partition ``sp``, follow the bounce algorithm and return the indices of the selected rows.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: SkewPartition([[], []]).to_selected_rows()</span>
<span class="sd">        []</span>
<span class="sd">        sage: SkewPartition([[1], []]).to_selected_rows()</span>
<span class="sd">        [0]</span>
<span class="sd">        sage: SkewPartition([[3, 2, 1], [1]]).to_selected_rows()</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        sage: SkewPartition([[6, 5, 3, 2, 2, 1], [2, 2]]).to_selected_rows()</span>
<span class="sd">        [0, 1, 2, 5]</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`selected_rows_to_maximum_root_ideal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># actually this may ONLY WORK for catty-connected skew-partitions, because i&#39;m not sure how we deal with &#39;missing&#39; rows</span>
    <span class="c1"># arguably we should call it a linked_skew_partition</span>
    <span class="c1"># record the indices of rows that have been used up</span>
    <span class="k">def</span> <span class="nf">bounce_path</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">blocked_rows</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="k">def</span> <span class="nf">bounce_path_piece</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">start_row_index</span><span class="p">,</span> <span class="n">blocked_rows</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
            <span class="c1"># Helper</span>
            <span class="c1"># this algo find the correct &quot;L&quot; piece of the path, where the bottom right cell is cell1, the bottom left is cell2, and the top left is cell3</span>
            <span class="c1"># Returns (top_row_index, is_end) which are the row index of cell3 and whether or not we &#39;broke free&#39; out of the top left cell of the skew-partition, respectively.</span>
            <span class="n">col_index2</span> <span class="o">=</span> <span class="n">skew_partition</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">start_row_index</span><span class="p">)</span>
            <span class="n">row_index3</span> <span class="o">=</span> <span class="n">skew_partition</span><span class="o">.</span><span class="n">top</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">col_index2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">row_index3</span> <span class="ow">in</span> <span class="n">blocked_rows</span><span class="p">:</span>
                <span class="n">row_index3</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># CATTY-CORNER ONLY line:</span>
            <span class="n">max_row_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">outer</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">row_index3</span> <span class="o">&gt;</span> <span class="n">max_row_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">row_index3</span><span class="p">,</span> <span class="kc">False</span>
        <span class="c1"># helper</span>
        <span class="n">new_blocked_rows</span> <span class="o">=</span> <span class="p">{</span><span class="n">row_index</span><span class="p">}</span>
        <span class="c1"># is_end says if you reached the end of the path</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">row_index</span><span class="p">,</span> <span class="n">is_end</span> <span class="o">=</span> <span class="n">bounce_path_piece</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">blocked_rows</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_end</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_blocked_rows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">row_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_blocked_rows</span>
    <span class="n">selected_rows</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">blocked_rows</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">outer_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">outer</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">row_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blocked_rows</span><span class="p">:</span>
            <span class="n">selected_rows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">row_index</span><span class="p">)</span>
            <span class="n">new_blocked_rows</span> <span class="o">=</span> <span class="n">bounce_path</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">blocked_rows</span><span class="p">)</span>
            <span class="n">blocked_rows</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_blocked_rows</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">selected_rows</span><span class="p">)</span></div>


<div class="viewcode-block" id="selected_rows_to_maximum_root_ideal"><a class="viewcode-back" href="../root_ideal.html#root_ideal.selected_rows_to_maximum_root_ideal">[docs]</a><span class="k">def</span> <span class="nf">selected_rows_to_maximum_root_ideal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">selected_indices</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given the dimension of the square and the selected rows, output the root ideal.</span>

<span class="sd">    Given the dimension ``n`` of the square and the selected rows whose indices are ``selected_indices``, return the maximum root ideal.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: selected_rows_to_maximum_root_ideal(1, [0])</span>
<span class="sd">        RootIdeal([])</span>
<span class="sd">        sage: selected_rows_to_maximum_root_ideal(2, [0, 1])</span>
<span class="sd">        RootIdeal([])</span>
<span class="sd">        sage: selected_rows_to_maximum_root_ideal(2, [0])</span>
<span class="sd">        RootIdeal([(0, 1)])</span>
<span class="sd">        sage: selected_rows_to_maximum_root_ideal(3, [0, 2])</span>
<span class="sd">        RootIdeal([(0, 1), (0, 2)])</span>
<span class="sd">        sage: selected_rows_to_maximum_root_ideal(4, [0, 2])</span>
<span class="sd">        RootIdeal([(0, 1), (0, 2), (0, 3), (1, 3)])</span>
<span class="sd">        sage: selected_rows_to_maximum_root_ideal(5, [0, 1, 4])</span>
<span class="sd">        RootIdeal([(0, 2), (0, 3), (0, 4), (1, 3), (1, 4)])</span>
<span class="sd">        sage: selected_rows_to_maximum_root_ideal(5, [0, 1])</span>
<span class="sd">        RootIdeal([(0, 2), (0, 3), (0, 4), (1, 3), (1, 4), (2, 4)])</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`skew_partition_to_selected_rows`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">root_ideal_cells</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">selected_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selected_indices</span><span class="p">)</span>
    <span class="n">permitted_col_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">-</span> <span class="n">selected_indices</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">permitted_col_indices</span><span class="p">:</span>
                <span class="n">smallest_unblocked_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">permitted_col_indices</span><span class="p">)</span>
                <span class="n">root_ideal_cells</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">smallest_unblocked_index</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
                <span class="n">permitted_col_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">smallest_unblocked_index</span><span class="p">)</span>
                <span class="n">selected_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">smallest_unblocked_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">root_ideal_cells</span><span class="p">)</span></div>


<div class="viewcode-block" id="skew_partition_to_removable_roots"><a class="viewcode-back" href="../root_ideal.html#root_ideal.skew_partition_to_removable_roots">[docs]</a><span class="k">def</span> <span class="nf">skew_partition_to_removable_roots</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a SkewPartition ``sp``, return the removable roots of the corresponding &#39;min&#39; or &#39;max&#39; root ideal.</span>

<span class="sd">    INPUTS:</span>

<span class="sd">    - ``sp`` -- a :class:`SkewPartition`</span>

<span class="sd">    OPTIONAL INPUTS:</span>

<span class="sd">    - ``type`` -- (default ``&#39;max&#39;``) the type of root ideal you want to use.  ``&#39;min&#39;`` is the minimum root ideal (as far as containment goes) and ``&#39;max&#39;`` is the maximum root ideal.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    A list of removable roots in order.</span>

<span class="sd">    TODO: find an example where min is different than max</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: SkewPartition([[], []]).to_removable_roots(type=&#39;min&#39;)</span>
<span class="sd">        []</span>
<span class="sd">        sage: SkewPartition([[], []]).to_removable_roots(type=&#39;max&#39;)</span>
<span class="sd">        []</span>

<span class="sd">        sage: SkewPartition([[3, 2, 1], [1]]).to_removable_roots(type=&#39;min&#39;)</span>
<span class="sd">        [(0, 2)]</span>
<span class="sd">        sage: SkewPartition([[3, 2, 1], [1]]).to_removable_roots(type=&#39;max&#39;)</span>
<span class="sd">        [(0, 2)]</span>

<span class="sd">        sage: SkewPartition([[6, 5, 3, 2, 2, 1], [2, 2]]).to_removable_roots(type=&#39;min&#39;)</span>
<span class="sd">        [(0, 3), (1, 4)]</span>
<span class="sd">        sage: SkewPartition([[6, 5, 3, 2, 2, 1], [2, 2]]).to_removable_roots(type=&#39;max&#39;)</span>
<span class="sd">        [(0, 3), (1, 4)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">type_shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad type.&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">skew_partition</span><span class="o">.</span><span class="n">is_linked</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">column_lengths</span><span class="p">())</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">inner</span><span class="p">()</span>
    <span class="n">rmvble_roots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">eta</span><span class="p">)):</span>
        <span class="n">mu_index</span> <span class="o">=</span> <span class="n">type_shift</span><span class="p">(</span><span class="n">eta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">type</span><span class="p">)</span>
        <span class="n">rmvble_root</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mu</span><span class="p">[</span><span class="n">mu_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">rmvble_roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rmvble_root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rmvble_roots</span></div>


<div class="viewcode-block" id="removable_roots_to_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.removable_roots_to_partition">[docs]</a><span class="k">def</span> <span class="nf">removable_roots_to_partition</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given the removable roots that define a root ideal, return the partition corresponding to that root ideal.</span>

<span class="sd">    Given the ``corners`` (removable roots) that define a root ideal as well as the size ``n`` of the `n` x `n` root ideal grid, return the partition corresponding to that root ideal.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    Consider that `n = 6` and the removable roots are `(0, 3)` and `(1, 4)`.  This function essentially draws a 6 x 6 grid, and then fills in the cells `(0, 3)` and `(1, 4)`.</span>

<span class="sd">    .. image:: _static/removable-roots-to-partition.JPG</span>
<span class="sd">        :width: 240px</span>
<span class="sd">        :align: center</span>
<span class="sd">        :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">    All cells to the north and east of the filled in ones also become shaded.  This shades the root ideal [(0, 3), (0, 4), (0, 5), (1, 4), (1, 5)] which corresponds to the partition [3, 2], so the function will return ``Partition([3, 2])``::</span>

<span class="sd">        sage: removable_roots_to_partition([(0, 3), (1, 4)], 6)</span>
<span class="sd">        [3, 2]</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`RootIdeals.init_from_removable_roots`, :meth:`to_partition`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">corners</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
    <span class="c1"># r is the row index or the &#39;y&#39; value</span>
    <span class="c1"># c is the col index of the &#39;x&#39; value</span>
    <span class="n">previous_r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">ptn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">corners</span><span class="p">:</span>
            <span class="n">current_r</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">current_c</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">current_r</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
                <span class="c1"># see how many rows to fill</span>
                <span class="n">num_rows</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">previous_r</span>
                <span class="n">ptn</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">current_c</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_rows</span>
                <span class="c1"># delete corner since it has now been used</span>
                <span class="n">previous_r</span> <span class="o">=</span> <span class="n">current_r</span>
                <span class="n">corners</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">Partition</span><span class="p">(</span><span class="n">ptn</span><span class="p">)</span></div>

<span class="c1"># RootIdeal stuff</span>


<span class="k">def</span> <span class="nf">_is_roots</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Helper function.</span>

<span class="sd">    Dirty indicator of whether object ``obj`` consists of roots.  Returns ``True`` if it is an iterable of pairs of natural numbers.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: _is_roots(((1, 4), (7, 2)))</span>
<span class="sd">        True</span>
<span class="sd">        sage: _is_roots(((-1, 4), (7, 2)))</span>
<span class="sd">        False</span>

<span class="sd">        sage: _is_roots([(1, 4), (7, 2)])</span>
<span class="sd">        True</span>
<span class="sd">        sage: _is_roots([(0, 4), (7, 2)])</span>
<span class="sd">        True</span>

<span class="sd">        sage: _is_roots(set([(1, 4), (7, 2)]))</span>
<span class="sd">        True</span>
<span class="sd">        sage: _is_roots(set([[1, 4], [7, 2]]))</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">()</span> <span class="ow">and</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">()</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="RootIdeal"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal">[docs]</a><span class="k">class</span> <span class="nc">RootIdeal</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A root ideal.</span>

<span class="sd">    Consider the k-1 staircase partition `[k-1, k-2, \ldots, 1]` positioned in the upper-right corner of a `k` x `k` grid.  The cells in the grid are labeled with (row_index, col_index) 0-based coordinates.  Now consider any right-justified subpartition of the staircase partition.  This is a RootIdeal.  However, it is expressed not as a partition but as a list of the cells it contains.</span>

<span class="sd">    See Definition 2.1 of [cat]_ for more.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    The partition `[3, 1]` in the 7 x 7 grid is the root ideal `[(0,4), (0,5), (0,6), (1,6)]`::</span>

<span class="sd">        sage: ri = RootIdeal([(0,4), (0,5), (0,6), (1,6)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lis</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># validate the roots</span>
        <span class="k">assert</span> <span class="n">_is_roots</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span>
        <span class="c1"># figure out n</span>
        <span class="n">n_best_guess</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">lis</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_best_guess</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;There is a root that falls outside of the n x n grid.  n is too small or one of the roots is incorrect.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n_best_guess</span>
        <span class="c1"># normalize the roots</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span>
        <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the hash of this root ideal.</span>

<span class="sd">        Thanks to this method, every :class:`RootIdeal` object is hashable, which is needed internally for other things to work.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: ri = RootIdeal([(0,4), (0,5), (0,6), (1,6)])</span>
<span class="sd">            sage: hash(ri)</span>
<span class="sd">            6635400540396992191</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="RootIdeal.next_within_bounds"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.next_within_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">next_within_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="p">[],</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;strict&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the next root ideal lexicographically that contains min and is contained in max.</span>

<span class="sd">        This is the same method as :meth:`Partition.next_within_bounds`, but using the corresponding root ideals instead of partitions.  It is best to understand that method before looking at this one.</span>

<span class="sd">        INPUTS:</span>

<span class="sd">        - ``self`` -- The RootIdeal.</span>

<span class="sd">        - ``min`` -- (default ``[]``, the empty root ideal) The &#39;minimum root ideal&#39; that ``next(self)`` must contain.</span>

<span class="sd">        - ``max`` -- (default ``None``) The &#39;maximum root ideal&#39; that ``next(self)`` must be contained in.  If set to ``None``, then there is no restriction.</span>

<span class="sd">        - ``type`` -- (default ``&#39;strict&#39;``) The type of root ideals allowed.  For example, &#39;strict&#39; for strictly decreasing root ideals, or ``None`` to allow any valid upper root ideal.</span>

<span class="sd">        Note also that the default type is ``&#39;strict&#39;``, whereas :meth:`Partition.next_within_bounds` has default type ``None``!</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: m = [(0,3), (1,3)]</span>
<span class="sd">            sage: M = [(0,1), (0,2), (0,3), (1,1), (1,2), (1,3)]</span>
<span class="sd">            sage: RootIdeal([(0, 3), (1, 3)], n=4).next_within_bounds(min=m, max=M)</span>
<span class="sd">            [(0, 2), (0, 3), (1, 3)]</span>
<span class="sd">            sage: RootIdeal([(0, 2), (0, 3), (1, 3)], n=4).next_within_bounds(min=m, max=M)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (1, 3)]</span>
<span class="sd">            sage: RootIdeal([(0, 1), (0, 2), (0, 3), (1, 3)], n=4).next_within_bounds(min=m, max=M)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)]</span>
<span class="sd">            sage: RootIdeal([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)], n=4).next_within_bounds(min=m, max=M) == None</span>
<span class="sd">            True</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`Partition.next_within_bounds`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">RootIdeal</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_roots</span><span class="p">(</span><span class="nb">min</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input parameter ``min`` must be a RootIdeal or an iterable of roots.  Your inputted ``min`` parameter was: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">min</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">RootIdeal</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_roots</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input parameter ``max`` must be a RootIdeal, an iterable of roots, or ``None``.  Your inputted ``min`` parameter was: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">max</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">ptn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_partition</span><span class="p">()</span>
        <span class="n">min_ptn</span> <span class="o">=</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">to_partition</span><span class="p">()</span>
        <span class="n">max_ptn</span> <span class="o">=</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">to_partition</span><span class="p">(</span>
        <span class="p">)</span> <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;strict&#39;</span><span class="p">,</span> <span class="s1">&#39;rational&#39;</span><span class="p">):</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="s1">&#39;strictly decreasing&#39;</span>
        <span class="n">next_ptn</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">next_within_bounds</span><span class="p">(</span><span class="n">ptn</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">min_ptn</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">max_ptn</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
        <span class="n">next_ri</span> <span class="o">=</span> <span class="n">RootIdeals</span><span class="p">()</span><span class="o">.</span><span class="n">init_from_partition</span><span class="p">(</span><span class="n">next_ptn</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">next_ri</span></div>

<div class="viewcode-block" id="RootIdeal.down"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.down">[docs]</a>    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">row_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Starting at the row corresponding to ``row_index``, return the down.</span>

<span class="sd">        Given a root ideal ``ri`` and a starting position ``row_index``, move right on that row until you hit the root ideal (you are now standing ontop of a cell of the root ideal), then move straight down until you hit the diagonal, and return the new index.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The picture below represents the root ideal ``ri``:</span>

<span class="sd">        .. image:: _static/root-ideal.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([3, 2, 1], 5)</span>
<span class="sd">            sage: ri.down(0)</span>
<span class="sd">            2</span>
<span class="sd">            sage: ri.down(1)</span>
<span class="sd">            3</span>
<span class="sd">            sage: ri.down(2)</span>
<span class="sd">            4</span>
<span class="sd">            sage: ri.down(3) == None</span>
<span class="sd">            True</span>
<span class="sd">            sage: ri.down(4) == None</span>
<span class="sd">            True</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`up`, :meth:`down_path`, :meth:`up_path`, :meth:`top`, :meth:`bottom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: I am assuming the cells in the root ideal are IN ORDER with y coordinates weakly increasing, and for fixed y, x strictly increasing</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ri</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">row_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="RootIdeal.up"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.up">[docs]</a>    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">,</span> <span class="n">col_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Starting at the column corresponding to ``col_index``, return the up.</span>

<span class="sd">        Same as :meth:`down`, but this time you start in the *column* indicated by ``column_index``, and move *up* until you hit the root ideal, then move *left* until you hit the diagonal.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The picture below represents the root ideal ``ri``:</span>

<span class="sd">        .. image:: _static/root-ideal.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([3, 2, 1], 5)</span>
<span class="sd">            sage: ri.up(0) == None</span>
<span class="sd">            True</span>
<span class="sd">            sage: ri.up(1) == None</span>
<span class="sd">            True</span>
<span class="sd">            sage: ri.up(2)</span>
<span class="sd">            0</span>
<span class="sd">            sage: ri.up(3)</span>
<span class="sd">            1</span>
<span class="sd">            sage: ri.up(4)</span>
<span class="sd">            2</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`down`, :meth:`down_path`, :meth:`up_path`, :meth:`top`, :meth:`bottom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">r</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="RootIdeal.down_path"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.down_path">[docs]</a>    <span class="k">def</span> <span class="nf">down_path</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a starting row index ``start_index``, perform :meth:`down` operations repeatedly until you can&#39;t anymore.</span>

<span class="sd">        Returns the resulting sequence of indices as a list.  (See [cat]_ Definition 5.2 for more)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The picture below represents the root ideal used in the example, and the path drawn on the picture depicts the down path for ``start_index`` 0 specifically:</span>

<span class="sd">        .. image:: _static/bottom.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([3, 2, 1], 5)</span>
<span class="sd">            sage: ri.down_path(0)</span>
<span class="sd">            [0, 2, 4]</span>
<span class="sd">            sage: ri.down_path(1)</span>
<span class="sd">            [1, 3]</span>
<span class="sd">            sage: ri.down_path(2)</span>
<span class="sd">            [2, 4]</span>
<span class="sd">            sage: ri.down_path(3)</span>
<span class="sd">            [3]</span>
<span class="sd">            sage: ri.down_path(4)</span>
<span class="sd">            [4]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`down`, :meth:`up`, :meth:`up_path`, :meth:`top`, :meth:`bottom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">next_func</span><span class="p">(</span><span class="n">index</span><span class="p">):</span> <span class="k">return</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_generate_path</span><span class="p">(</span><span class="n">next_func</span><span class="p">,</span> <span class="n">start_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeal.up_path"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.up_path">[docs]</a>    <span class="k">def</span> <span class="nf">up_path</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Same as :meth:`down_path`, but uses a *column* index to start with, and applies *up* operations repeatedly.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The picture below represents the root ideal ``ri``:</span>

<span class="sd">        .. image:: _static/root-ideal.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([3, 2, 1], 5)</span>
<span class="sd">            sage: ri.up_path(0)</span>
<span class="sd">            [0]</span>
<span class="sd">            sage: ri.up_path(1)</span>
<span class="sd">            [1]</span>
<span class="sd">            sage: ri.up_path(2)</span>
<span class="sd">            [2, 0]</span>
<span class="sd">            sage: ri.up_path(3)</span>
<span class="sd">            [3, 1]</span>
<span class="sd">            sage: ri.up_path(4)</span>
<span class="sd">            [4, 2, 0]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`down`, :meth:`up`, :meth:`down_path`, :meth:`top`, :meth:`bottom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">next_func</span><span class="p">(</span><span class="n">index</span><span class="p">):</span> <span class="k">return</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_generate_path</span><span class="p">(</span><span class="n">next_func</span><span class="p">,</span> <span class="n">start_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeal.top"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.top">[docs]</a>    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a column index ``start_index``, look at it&#39;s :meth:`up_path` and return the final index.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The picture below represents the root ideal ``ri``:</span>

<span class="sd">        .. image:: _static/root-ideal.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([3, 2, 1], 5)</span>
<span class="sd">            sage: ri.top(0)</span>
<span class="sd">            0</span>
<span class="sd">            sage: ri.top(1)</span>
<span class="sd">            1</span>
<span class="sd">            sage: ri.top(2)</span>
<span class="sd">            0</span>
<span class="sd">            sage: ri.top(3)</span>
<span class="sd">            1</span>
<span class="sd">            sage: ri.top(4)</span>
<span class="sd">            0</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`down`, :meth:`up`, :meth:`down_path`, :meth:`up_path`, :meth:`bottom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">up_path</span><span class="p">(</span><span class="n">start_index</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="RootIdeal.bottom"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.bottom">[docs]</a>    <span class="k">def</span> <span class="nf">bottom</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a row index ``start_index``, look at it&#39;s :meth:`down_path` and return the final index.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The picture below represents the root ideal used in the examples, and the path drawn on the picture depicts the down path for index 0 specifically, demonstrating that ``bottom(0)`` should be 4:</span>

<span class="sd">        .. image:: _static/bottom.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([3, 2, 1], 5)</span>
<span class="sd">            sage: ri.bottom(0)</span>
<span class="sd">            4</span>
<span class="sd">            sage: ri.bottom(1)</span>
<span class="sd">            3</span>
<span class="sd">            sage: ri.bottom(2)</span>
<span class="sd">            4</span>
<span class="sd">            sage: ri.bottom(3)</span>
<span class="sd">            3</span>
<span class="sd">            sage: ri.bottom(4)</span>
<span class="sd">            4</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`down`, :meth:`up`, :meth:`down_path`, :meth:`up_path`, :meth:`top`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">down_path</span><span class="p">(</span><span class="n">start_index</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="RootIdeal.down_path_column_lengths_part"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.down_path_column_lengths_part">[docs]</a>    <span class="k">def</span> <span class="nf">down_path_column_lengths_part</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">,</span> <span class="n">ptn</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is `\mu_i` in Definition 2.3 of [scat]_.</span>

<span class="sd">        This exists mainly as a helper function for :meth:`down_path_column_lengths`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([5, 2, 2, 2], 6)</span>
<span class="sd">            sage: ptn = [7, 6, 5, 2, 2, 2]</span>

<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 0)</span>
<span class="sd">            15</span>
<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 1)</span>
<span class="sd">            8</span>
<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 3)</span>
<span class="sd">            4</span>
<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 2)</span>
<span class="sd">            7</span>
<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 4)</span>
<span class="sd">            2</span>
<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 5)</span>
<span class="sd">            2</span>
<span class="sd">            sage: ri.down_path_column_lengths_part(ptn, 6)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            IndexError: list index out of range</span>

<span class="sd">        This is also the lengths of the bounce paths in [cat]_ Definition 5.2.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ptn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">down_path</span><span class="p">(</span><span class="n">start_index</span><span class="p">))</span></div>

<div class="viewcode-block" id="RootIdeal.down_path_column_lengths"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.down_path_column_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">down_path_column_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptn</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is the column shape `\mu&#39;` as defined by Definition 2.3 of [scat]_.</span>

<span class="sd">        It is also introduced in the second paragraph of the overview as `\mathfrak{cs}(\Psi, \lambda)`.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        In Example 2.4 of [scat]_, the following</span>

<span class="sd">        ..  image:: _static/example2.4.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,1), (0,2), (0,3), (0,4), (0,5), (1,4), (1,5), (2,4), (2,5), (3,4), (3,5)] and the partition 7 6 5 2 2 2</span>

<span class="sd">        depicts the root ideal in red and the partition on the diagonal::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([5, 2, 2, 2], 6)</span>
<span class="sd">            sage: ptn = [7, 6, 5, 2, 2, 2]</span>
<span class="sd">            sage: ri.down_path_column_lengths(ptn)</span>
<span class="sd">            [15, 7, 4, 2]</span>

<span class="sd">        This is also the lengths of the bounce paths in [cat]_ Definition 5.2.</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`down_path`</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">ptn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># n is the side length of the square</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">indices_available</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices_available</span><span class="p">:</span>
                    <span class="c1"># add the kthing to mu</span>
                    <span class="n">mu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">down_path_column_lengths_part</span><span class="p">(</span><span class="n">ptn</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
                    <span class="c1"># remove indices from future draws</span>
                    <span class="n">dpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_path</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">indices_available</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dpath</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Partition</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeal.to_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.to_partition">[docs]</a>    <span class="k">def</span> <span class="nf">to_partition</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a root ideal (list of cells), return the corresponding partition (the row shape of the root ideal).</span>

<span class="sd">        Returns a :class:`Partition` object.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The red part of the following picture (please ignore the diagonal) represents the root ideal [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)].</span>

<span class="sd">        .. image:: _static/Ksi.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)] inside a 6 by 6 grid.</span>

<span class="sd">        But it can also be interpreted as the partition 5 2 2 2 (in the Hebrew convention).  Therefore, ``to_partition()`` acting on the root ideal will output 5 2 2 2::</span>

<span class="sd">            sage: ri = RootIdeal([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)])</span>
<span class="sd">            sage: ri.to_partition()</span>
<span class="sd">            [5, 2, 2, 2]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`RootIdeals.init_from_partition`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root_ideal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">root_ideal</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root_ideal</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root_ideal</span><span class="p">:</span>
            <span class="n">ptn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_r</span> <span class="o">=</span> <span class="n">root_ideal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ptn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">root_ideal</span><span class="p">:</span>
                <span class="n">ptn</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Partition</span><span class="p">(</span><span class="n">ptn</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeal.is_strict"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.is_strict">[docs]</a>    <span class="k">def</span> <span class="nf">is_strict</span><span class="p">(</span><span class="n">ri</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return if this root ideal&#39;s corresponding partition is strictly decreasing.</span>

<span class="sd">        Given a root ideal ``ri``, check to see if it is a *strict root ideal*, as defined in Example 2.4 of [scat]_.  This merely means that it&#39;s corresponding partition is strictly decreasing!</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        In the following images, ignore the index on the diagonal and look only at the root ideal in red.</span>

<span class="sd">        .. image:: _static/Phi.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal corresponding to the partition  8 6 5 3 2</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([8, 6, 5, 3, 2], 9)</span>
<span class="sd">            sage: ri.is_strict()</span>
<span class="sd">            True</span>

<span class="sd">        .. image:: _static/Ksi.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal corresponding to the partition  5 2 2 2</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri = RootIdeals().init_from_partition([5, 2, 2, 2], 6)</span>
<span class="sd">            sage: ri.is_strict()</span>
<span class="sd">            False</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`partition.is_strictly_decreasing`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptn</span> <span class="o">=</span> <span class="n">ri</span><span class="o">.</span><span class="n">to_partition</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">partition</span><span class="o">.</span><span class="n">is_strictly_decreasing</span><span class="p">(</span><span class="n">ptn</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeal.complement"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeal.complement">[docs]</a>    <span class="k">def</span> <span class="nf">complement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return this root ideal&#39;s complement in the upper-staircase-shape.</span>

<span class="sd">        Given a root ideal (or just an iterable of roots), return it&#39;s complement in the upper-staircase-shape, the result being a root ideal (or just an iterable of roots).</span>

<span class="sd">        INPUTS:</span>

<span class="sd">        - ``ri`` -- a root ideal</span>

<span class="sd">        OPTIONAL INPUTS:</span>

<span class="sd">        - ``n`` -- (default ``None``) the side length of the n x n box you want the complement to be taken over.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The two root ideals depicted below are complements of each other:</span>

<span class="sd">        .. image:: _static/root-ideal.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)]</span>

<span class="sd">        .. image:: _static/root-ideal-complement.JPG</span>
<span class="sd">            :width: 180px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,1), (1,2), (2,3), (3,4)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: ri1 = RootIdeal([(0,2), (0,3), (0,4), (1,3), (1,4), (2,4)])</span>
<span class="sd">            sage: ri2 = RootIdeal([(0,1), (1,2), (2,3), (3,4)])</span>
<span class="sd">            sage: ri1.complement() == ri2</span>
<span class="sd">            True</span>
<span class="sd">            sage: ri2.complement() == ri1</span>
<span class="sd">            True</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`RootIdeals.init_staircase`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">ri_staircase</span> <span class="o">=</span> <span class="n">RootIdeals</span><span class="p">()</span><span class="o">.</span><span class="n">init_staircase</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">ri_complement_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ri_staircase</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ri_complement</span> <span class="o">=</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">ri_complement_set</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ri_complement</span></div></div>


<div class="viewcode-block" id="RootIdeals"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals">[docs]</a><span class="k">class</span> <span class="nc">RootIdeals</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The family of root ideals.</span>

<span class="sd">    Use this class as a factory to initialize a :class:`RootIdeal` object with any valid identifying data.  See the ``init_from...`` methods below for ways to create a root ideal.  Remember that you can also create a root ideal directly from an iterable of roots using :class:`RootIdeal`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RootIdeals.init_from_removable_roots"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_from_removable_roots">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_removable_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given the removable roots ``corners`` of a root ideal and the size length `n` of the `n` x `n` grid, return the root ideal itself.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The root ideal [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)] in the `6` x `6` grid shown below in red (please ignore the diagonal) has removable roots `(0, 1)` and `(3, 4)`:</span>

<span class="sd">        .. image:: _static/Ksi.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal corresponding to the partition  5 2 2 2</span>

<span class="sd">        ::</span>

<span class="sd">            sage: removable_roots_to_root_ideal({(0, 1), (3, 4)}, 6)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptn</span> <span class="o">=</span> <span class="n">removable_roots_to_partition</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_partition</span><span class="p">(</span><span class="n">ptn</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ri</span></div>

<div class="viewcode-block" id="RootIdeals.init_from_skew_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_from_skew_partition">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_skew_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;removable roots&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a :class:`SkewPartition` ``sp`` and a type of root ideal (&#39;max&#39; or &#39;min&#39;), return the corresponding root ideal.</span>

<span class="sd">        A type of ``&#39;min&#39;`` returns `\Phi(\lambda, \mu)` while a type of ``&#39;max&#39;`` returns `\Phi^+(\lambda, \mu)` as notated in [scat]_ at the bottom of page 1.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: RootIdeals().init_from_skew_partition(SkewPartition([[4, 2, 1, 1], [2, 1]]), type=&#39;min&#39;)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (1, 3)]</span>
<span class="sd">            sage: RootIdeals().init_from_skew_partition(SkewPartition([[4, 2, 1, 1], [2, 1]]), type=&#39;max&#39;)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)]</span>

<span class="sd">            sage: sp = SkewPartition([[6, 5, 3, 2, 2, 1], [2, 2]])</span>
<span class="sd">            sage: RootIdeals().init_from_skew_partition(sp)</span>
<span class="sd">            [(0, 3), (0, 4), (0, 5), (1, 4), (1, 5)]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`init_all_from_skew_partition`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;removable roots&#39;</span><span class="p">:</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="n">skew_partition_to_removable_roots</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">outer</span><span class="p">())</span>
            <span class="n">root_ideal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_removable_roots</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;bounce&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">!=</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;The bounce algorithm can only yield the maximum root ideal (type=max).&#39;</span><span class="p">)</span>
            <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">skew_partition_to_selected_rows</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">outer</span><span class="p">())</span>
            <span class="n">root_ideal</span> <span class="o">=</span> <span class="n">selected_rows_to_maximum_root_ideal</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">selected_indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The requested algorithm &quot;</span><span class="si">{}</span><span class="s1">&quot; does not exist.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">algorithm</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeals.init_all_from_skew_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_all_from_skew_partition">[docs]</a>    <span class="k">def</span> <span class="nf">init_all_from_skew_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;strict&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a :class:`SkewPartition` ``sp``, find the corresponding set (but given as a list here) of root ideals.</span>

<span class="sd">        (This is the set `\{\Psi \in \Delta^+(\mathfrak{R}) \mid \Phi(\lambda, \mu) \subset \Psi \subset \Phi^+(\lambda, \mu)\} = [(\lambda, \mu)]` found in [scat]_ at the bottom of page 1.)</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: sp = SkewPartition([[4, 2, 1, 1], []])</span>
<span class="sd">            sage: RootIdeals().init_all_from_skew_partition(sp)</span>
<span class="sd">            [[(0, 1), (0, 2), (0, 3), (1, 3)], [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)]]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`init_from_skew_partition`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We could change this to an iterator if users may not want all the root ideals.</span>
        <span class="n">min_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_skew_partition</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>
        <span class="n">max_ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_skew_partition</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">outer</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">next_func</span><span class="p">(</span><span class="n">ri</span><span class="p">):</span> <span class="k">return</span> <span class="n">ri</span><span class="o">.</span><span class="n">next_within_bounds</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">min_ri</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">max_ri</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
        <span class="n">ris</span> <span class="o">=</span> <span class="n">_generate_path</span><span class="p">(</span><span class="n">next_func</span><span class="p">,</span> <span class="n">min_ri</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ris</span></div>

<div class="viewcode-block" id="RootIdeals.init_k_schur_from_pseudo_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_k_schur_from_pseudo_partition">[docs]</a>    <span class="k">def</span> <span class="nf">init_k_schur_from_pseudo_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a ``k``-bounded &quot;pseudo-partition&quot; ``seq`` `= \mu` and the dimension `n` of the `n` x `n` grid, return the corresponding `k`-Schur root ideal `\Delta^k(\mu)`, as defined in [cat]_ Definition 2.2 as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Delta^k(\mu) = \{(i,j) \in \Delta^+_n \mid k - \mu_i + i &lt; j \}</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The following diagram depicts the `k`-bounded partition on the diagonal and the resulting `k`-schur root ideal:</span>

<span class="sd">        .. image:: _static/k-schur-root-ideal.JPG</span>
<span class="sd">            :height: 200px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The partition 3 3 2 2 2 and the root ideal [(0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (2, 5), (2, 6), (2, 7), (3, 6), (3, 7), (4, 7)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: k_ri = RootIdeals().init_k_schur_from_partition([3, 3, 2, 2, 2], 4, n=8)</span>
<span class="sd">            sage: k_ri.to_partition()</span>
<span class="sd">            [6, 5, 3, 2, 1]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`is_pseudo_partition`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_pseudo_partition</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">term</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="n">ri</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">part</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeals.init_from_partition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_from_partition">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptn</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a partition and the size of the square, return the corresponding root ideal.  (This is the inverse function to :meth:`RootIdeal.to_partition` in the context of an `n` x `n` grid.)</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        The red part of the following picture (please ignore the diagonal) can be interpreted as the partition 5 2 2 2 (in the Hebrew convention):</span>

<span class="sd">        .. image:: _static/Ksi.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)] inside a 6 by 6 grid.</span>

<span class="sd">        Therefore the partition 5 2 2 2 with `n=6` corresponds to the root ideal [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]::</span>

<span class="sd">            sage: RootIdeals().init_from_partition([5, 2, 2, 2], 6)</span>
<span class="sd">            [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ptn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ptn</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ptn</span>
        <span class="n">ptn</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">ptn</span><span class="p">)</span>
        <span class="n">root_ideal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ptn</span><span class="p">):</span>
            <span class="n">root_ideal</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">part</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">root_ideal</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeals.init_staircase"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_staircase">[docs]</a>    <span class="k">def</span> <span class="nf">init_staircase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given `n`, return the root ideal commonly denoted `\Delta^+`, which is the maximum possible root ideal in an `n` x `n` grid.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: RootIdeals().init_staircase(3)</span>
<span class="sd">            [(0,1), (0,2), (1,2)]</span>
<span class="sd">            sage: RootIdeals().init_staircase(4)</span>
<span class="sd">            [(0,1), (0,2), (0,3), (1,2), (1,3), (2,3)]</span>

<span class="sd">        ..  SEEALSO::</span>

<span class="sd">            :meth:`staircase_shape`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_partition</span><span class="p">(</span><span class="n">staircase_shape</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="RootIdeals.init_parabolic_from_composition"><a class="viewcode-back" href="../root_ideal.html#root_ideal.RootIdeals.init_parabolic_from_composition">[docs]</a>    <span class="k">def</span> <span class="nf">init_parabolic_from_composition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a composition of positive integers, return the parabolic root ideal.</span>

<span class="sd">        Given a composition `\eta` of positive integers, return the parabolic root ideal `\Delta(\eta)` defined by</span>

<span class="sd">        ..  math::</span>

<span class="sd">            \Delta(\eta) := \{ \alpha \in \Delta^+_{|\eta|} \:\text{above the block diagonal with block sizes}\: \eta_1, \ldots, \eta_r\}</span>

<span class="sd">        in [cat]_ just below Conjecture 3.3.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        .. image:: _static/parabolic-root-ideal.png</span>
<span class="sd">            :width: 200px</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: The root ideal [(0,1), (0,2), (0,3), (0,4), (0,5), (1,4), (1,5), (2,4), (2,5), (3,4), (3,5)]</span>

<span class="sd">        ::</span>

<span class="sd">            sage: RootIdeals().init_parabolic_from_composition([1, 3, 2])</span>
<span class="sd">            [(0,1), (0,2), (0,3), (0,4), (0,5), (1,4), (1,5), (2,4), (2,5), (3,4), (3,5)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">partition</span><span class="o">.</span><span class="n">_is_sequence</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">term</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">composition</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="p">(</span><span class="n">Partition</span><span class="p">,</span> <span class="n">Composition</span><span class="p">)):</span>
            <span class="n">composition</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
        <span class="n">cells_complement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index_previous</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">composition</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_previous</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index_previous</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">term</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">cells_complement</span> <span class="o">+=</span> <span class="n">cells</span>
            <span class="n">index_previous</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
        <span class="n">complement_ri</span> <span class="o">=</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">cells_complement</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="n">complement_ri</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ri</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  
    
      <a href="../../index.html"><img src="../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../index.html">k-Schur combinatorics for SageMath 0.1.4 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Matthew Lancellotti, George Seelinger, Jennifer Morse.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>