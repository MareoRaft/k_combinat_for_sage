
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>all &#8212; k-Schur combinatorics for SageMath 0.1.4 documentation</title>
    <link rel="stylesheet" href="../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="icon" href="../_static/sageicon.png" type="image/x-icon" />
    <script src="../_static/thebe.js" type="text/javascript"></script>
    <script src="../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  
    
      <a href="../../index.html"><img src="../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../index.html">k-Schur combinatorics for SageMath 0.1.4 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for all</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains all functionalities that are not already organized into the other files.  New functionalities written to the library often appear here, and eventually get organized into separate files.</span>

<span class="sd">AUTHORS:</span>

<span class="sd">- Matthew Lancellotti (2018): Initial version</span>

<span class="sd">REFERENCES:</span>

<span class="sd">.. [Fun] `Raising operators and the Littlewood-Richardson polynomials &lt;https://arxiv.org/pdf/1203.4729.pdf&gt;`_.  Fun, Alex.</span>
<span class="sd">.. [LN] `Finite sum Cauchy identity for dual Grothendieck polynomials &lt;https://projecteuclid.org/download/pdf_1/euclid.pja/1407415930&gt;`_.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#*****************************************************************************</span>
<span class="c1">#  Copyright (C) 2018 Matthew Lancellotti &lt;mvlancellotti@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#                  http://www.gnu.org/licenses/</span>
<span class="c1">#*****************************************************************************</span>

<span class="kn">from</span> <span class="nn">sage.all</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">core</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">core</span>
<span class="kn">from</span> <span class="nn">partition</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">partition</span>
<span class="kn">from</span> <span class="nn">partition</span> <span class="k">import</span> <span class="n">_is_sequence</span>
<span class="kn">from</span> <span class="nn">skew_partition</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">skew_partition</span>
<span class="kn">from</span> <span class="nn">k_shape</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">k_shape</span>
<span class="kn">from</span> <span class="nn">root_ideal</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">root_ideal</span>
<span class="kn">from</span> <span class="nn">strong_marked_tableau</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">strong_marked_tableau</span>
<span class="n">SetPartitionsAk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsBk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsIk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsPRk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsPk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsRk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsSk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">SetPartitionsTk</span> <span class="o">=</span> <span class="kc">None</span>



<span class="c1"># HELPERS</span>
<span class="k">def</span> <span class="nf">_is_k_schur</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Helper function.</span>

<span class="sd">    Checks if ``obj`` is coming from the &#39;kSchur_with_category&#39; class.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">    An example of a `k`-schur function::</span>

<span class="sd">        sage: Sym = SymmetricFunctions(QQ)</span>
<span class="sd">        sage: KB = Sym.kBoundedSubspace(3,1)</span>
<span class="sd">        sage: ks = KB.kschur()</span>
<span class="sd">        sage: _is_k_schur(ks[2, 1] + ks[1, 1])</span>
<span class="sd">        True</span>

<span class="sd">    The following is a schur function, *not* a `k`-schur function:</span>

<span class="sd">        sage: Sym = SymmetricFunctions(QQ)</span>
<span class="sd">        sage: s = Sym.schur()</span>
<span class="sd">        sage: _is_k_schur(s[2, 1] + s[1, 1])</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">classname</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">classname</span> <span class="o">==</span> <span class="s1">&#39;kSchur_with_category&#39;</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># MAIN</span>
<div class="viewcode-block" id="get_k_rectangles"><a class="viewcode-back" href="../all.html#all.get_k_rectangles">[docs]</a><span class="k">def</span> <span class="nf">get_k_rectangles</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the list of ``k``-rectangles.</span>

<span class="sd">    A __``k``-rectangle__ is a partition whose Ferrer&#39;s diagram is a rectangle whose largest hook-length is `k`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: get_k_rectangles(0)</span>
<span class="sd">        []</span>
<span class="sd">        sage: get_k_rectangles(1)</span>
<span class="sd">        [[1]]</span>
<span class="sd">        sage: get_k_rectangles(2)</span>
<span class="sd">        [[2], [1, 1]]</span>
<span class="sd">        sage: get_k_rectangles(3)</span>
<span class="sd">        [[3], [2, 2], [1, 1, 1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Partition</span><span class="p">([</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">k_rectangle_dimension_list</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span></div>


<div class="viewcode-block" id="get_k_irreducible_partition_lists"><a class="viewcode-back" href="../all.html#all.get_k_irreducible_partition_lists">[docs]</a><span class="k">def</span> <span class="nf">get_k_irreducible_partition_lists</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the list of ``k``-irreducible partitions.</span>

<span class="sd">    The `k`-irreducible partitions are output at lists, not Partition objects.</span>

<span class="sd">    There are `k!` such partitions, and computation time starts to get slow around `k = 10`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: get_k_irreducible_partition_lists(0)</span>
<span class="sd">        [[]]</span>
<span class="sd">        sage: get_k_irreducible_partition_lists(1)</span>
<span class="sd">        [[]]</span>
<span class="sd">        sage: get_k_irreducible_partition_lists(2)</span>
<span class="sd">        [[], [1]]</span>
<span class="sd">        sage: get_k_irreducible_partition_lists(3)</span>
<span class="sd">        [[], [1], [1, 1], [2], [2, 1], [2, 1, 1]]</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`get_k_irreducible_partitions`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">()(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">k_irr_ptns</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="c1"># NO rows of length k</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">new_k_irr_ptns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ptn</span> <span class="ow">in</span> <span class="n">k_irr_ptns</span><span class="p">:</span>
            <span class="c1"># at most i rows of length k-i where 1 &lt;= i &lt; k</span>
            <span class="k">for</span> <span class="n">num_rows</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">new_ptn</span> <span class="o">=</span> <span class="n">ptn</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">num_rows</span>
                <span class="n">new_k_irr_ptns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ptn</span><span class="p">)</span>
        <span class="n">k_irr_ptns</span> <span class="o">=</span> <span class="n">new_k_irr_ptns</span>
    <span class="k">return</span> <span class="n">k_irr_ptns</span></div>


<div class="viewcode-block" id="get_k_irreducible_partitions"><a class="viewcode-back" href="../all.html#all.get_k_irreducible_partitions">[docs]</a><span class="k">def</span> <span class="nf">get_k_irreducible_partitions</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the list of ``k``-irreducible partitions.</span>

<span class="sd">    The output is a list of :class:`Partition` objects.</span>

<span class="sd">    There are `k!` such partitions, and computation time starts to get slow around `k = 10`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: get_k_irreducible_partitions(0)</span>
<span class="sd">        [[]]</span>
<span class="sd">        sage: get_k_irreducible_partitions(1)</span>
<span class="sd">        [[]]</span>
<span class="sd">        sage: get_k_irreducible_partitions(2)</span>
<span class="sd">        [[], [1]]</span>
<span class="sd">        sage: get_k_irreducible_partitions(3)</span>
<span class="sd">        [[], [1], [1, 1], [2], [2, 1], [2, 1, 1]]</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`get_k_irreducible_partition_lists`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Partition</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">get_k_irreducible_partition_lists</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span></div>


<div class="viewcode-block" id="size_to_num_linked_partition_self_pairs"><a class="viewcode-back" href="../all.html#all.size_to_num_linked_partition_self_pairs">[docs]</a><span class="k">def</span> <span class="nf">size_to_num_linked_partition_self_pairs</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a natural number ``size``, count how many partitions `l` of size ``size`` have the property that `(l, l)` has a corresponding skew-linked-diagram.</span>

<span class="sd">    Note: A &#39;skew-linked-diagram&#39; is a :class:`SkewPartition` that is linked.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: size_to_num_linked_partition_self_pairs(0)</span>
<span class="sd">        1</span>
<span class="sd">        sage: size_to_num_linked_partition_self_pairs(1)</span>
<span class="sd">        1</span>
<span class="sd">        sage: size_to_num_linked_partition_self_pairs(2)</span>
<span class="sd">        1</span>
<span class="sd">        sage: size_to_num_linked_partition_self_pairs(3)</span>
<span class="sd">        2</span>

<span class="sd">    ..  SEEALSO::</span>

<span class="sd">        :meth:`SkewPartition.is_linked`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># DO NOT ADD TO SAGE</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">row_col_to_skew_partition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span></div>


<span class="k">def</span> <span class="nf">print_sequence</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">num_terms</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
    <span class="c1"># DO NOT ADD TO SAGE</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">num_terms</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;n=</span><span class="si">{}</span><span class="se">\t</span><span class="si">{}</span><span class="s1">=f(n)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>


<div class="viewcode-block" id="size_to_k_shapes"><a class="viewcode-back" href="../all.html#all.size_to_k_shapes">[docs]</a><span class="k">def</span> <span class="nf">size_to_k_shapes</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># DO NOT ADD TO SAGE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return all partitions of size ``n`` that are ``k``-shapes. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ptn</span> <span class="k">for</span> <span class="n">ptn</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_k_shape</span><span class="p">(</span><span class="n">ptn</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span></div>


<span class="k">def</span> <span class="nf">size_to_num_k_shapes</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># DO NOT ADD TO SAGE</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">size_to_k_shapes</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>


<div class="viewcode-block" id="straighten"><a class="viewcode-back" href="../all.html#all.straighten">[docs]</a><span class="k">def</span> <span class="nf">straighten</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Perform Schur function straightening by the Schur straightening rule.</span>

<span class="sd">    See [cat]_, Prop. 4.1.  Also known as the slinky rule.</span>

<span class="sd">    .. MATH::</span>

<span class="sd">        s_{\gamma}(\mathbf{x}) = \begin{cases}</span>
<span class="sd">            \text{sgn}(\gamma+\rho) s_{\text{sort}(\gamma+\rho) -\rho}(\mathbf{x}) &amp; \text{if } \gamma + \rho \text{ has distinct nonnegative parts,} \\</span>
<span class="sd">            0 &amp; \text{otherwise,}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where `\rho=(\ell-1,\ell-2,\dots,0)`, `\text{sort}(\beta)` denotes the weakly decreasing sequence obtained by sorting `\beta`, and `\text{sgn}(\beta)` denotes the sign of the (shortest possible) sorting permutation.</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    We know s[2, 1, 3] := -s[2, 2, 2]::</span>

<span class="sd">        sage: s = SymmetricFunctions(QQ).s()</span>
<span class="sd">        sage: straighten(s, [2, 1, 3])</span>
<span class="sd">        -s[2, 2, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">has_nonnegative_parts</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_distinct_parts</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lis</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">number_of_noninversions</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)):</span>
                <span class="c1"># i &lt; j is already enforced</span>
                <span class="k">if</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lis</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;SymmetricFunctionAlgebra_monomial_with_category&#39;</span><span class="p">,</span> <span class="s1">&#39;SymmetricFunctionAlgebra_dual_with_category&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span>
            <span class="s1">&#39;Straightening does not exist (that i know of) for the monomial basis or the forgotten/dual basis.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;HallLittlewood_qp_with_category&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compositional_hall_littlewood_Qp</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">base_ring</span><span class="p">(),</span> <span class="n">t</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;SymmetricFunctionAlgebra_homogeneous_with_category&#39;</span><span class="p">,</span> <span class="s1">&#39;SymmetricFunctionAlgebra_elementary_with_category&#39;</span><span class="p">,</span> <span class="s1">&#39;SymmetricFunctionAlgebra_power_with_category&#39;</span><span class="p">,</span> <span class="s1">&#39;SymmetricFunctionAlgebra_witt_with_category&#39;</span><span class="p">):</span>
        <span class="n">new_gamma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">gamma</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">has_nonnegative_parts</span><span class="p">(</span><span class="n">new_gamma</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">(</span><span class="n">new_gamma</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;SymmetricFunctionAlgebra_schur_with_category&#39;</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="o">+</span> <span class="n">r</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">has_distinct_parts</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="ow">and</span> <span class="n">has_nonnegative_parts</span><span class="p">(</span><span class="n">combined</span><span class="p">):</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">number_of_noninversions</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>
            <span class="n">sort_combined</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">combined</span><span class="p">))</span>
            <span class="n">new_gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">sc</span> <span class="o">-</span> <span class="n">r</span> <span class="k">for</span> <span class="n">sc</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sort_combined</span><span class="p">,</span> <span class="n">rho</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">basis</span><span class="p">(</span><span class="n">Partition</span><span class="p">(</span><span class="n">new_gamma</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The input parameter &#39;basis&#39; should be a symmetric function basis.  For example, &#39;s = SymmetricFunctions(QQ).s(); straighten(s, [2, 1, 3])&#39;, or one could use &#39;h&#39; instead of &#39;s&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ShiftingSequenceSpace"><a class="viewcode-back" href="../all.html#all.ShiftingSequenceSpace">[docs]</a><span class="k">class</span> <span class="nc">ShiftingSequenceSpace</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A helper for :class:`ShiftingOperatorAlgebra.`</span>

<span class="sd">    Helps :class:`ShiftingOperatorAlgebra` know which indices are valid and which indices are not for the basis.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: S = ShiftingSequenceSpace()</span>
<span class="sd">        sage: (1, -1) in S</span>
<span class="sd">        True</span>
<span class="sd">        sage: (1, -1, 0, 9) in S</span>
<span class="sd">        True</span>
<span class="sd">        sage: [1, -1] in S</span>
<span class="sd">        False</span>
<span class="sd">        sage: (0.5, 1) in S</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">IntegerRing</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="c1"># category = InfiniteEnumeratedSets()</span>
        <span class="c1"># Parent.__init__(self, category=category)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns ``True`` if and only if ``seq`` is a valid shifting sequence.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingSequenceSpace()</span>
<span class="sd">            sage: (1, -1) in S</span>
<span class="sd">            True</span>
<span class="sd">            sage: (1, -1, 0, 9) in S</span>
<span class="sd">            True</span>
<span class="sd">            sage: [1, -1] in S</span>
<span class="sd">            False</span>
<span class="sd">            sage: (0.5, 1) in S</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">)</span>

    <span class="n">CHECK_ERROR_MESSAGE</span> <span class="o">=</span> <span class="s1">&#39;Expected valid index (a tuple of </span><span class="si">{base}</span><span class="s1">), but instead received </span><span class="si">{seq}</span><span class="s1">.&#39;</span>

<div class="viewcode-block" id="ShiftingSequenceSpace.check"><a class="viewcode-back" href="../all.html#all.ShiftingSequenceSpace.check">[docs]</a>    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Verify that ``seq`` is a valid shifting sequence.</span>

<span class="sd">        If it is not, raise an error.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingSequenceSpace()</span>
<span class="sd">            sage: S.check((1, -1))</span>
<span class="sd">            sage: S.check((1, -1, 0, 9))</span>
<span class="sd">            sage: S.check([1, -1])</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: Expected valid index (a tuple of Integer Ring), but instead received [1, -1].</span>
<span class="sd">            sage: S.check((0.5, 1))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: Expected valid index (a tuple of Integer Ring), but instead received [1, -1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CHECK_ERROR_MESSAGE</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">base</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="n">seq</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RaisingSequenceSpace"><a class="viewcode-back" href="../all.html#all.RaisingSequenceSpace">[docs]</a><span class="k">class</span> <span class="nc">RaisingSequenceSpace</span><span class="p">(</span><span class="n">ShiftingSequenceSpace</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A helper for :class:`RaisingOperatorAlgebra`.</span>

<span class="sd">    Helps :class:`RaisingOperatorAlgebra` know which indices are valid and which indices are not for the basis.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: RS = RaisingSequenceSpace()</span>
<span class="sd">        sage: (1, -1) in RS</span>
<span class="sd">        True</span>
<span class="sd">        sage: (1, 0, -1) in RS</span>
<span class="sd">        True</span>
<span class="sd">        sage: (1, -1, 0, 9) in RS</span>
<span class="sd">        False</span>
<span class="sd">        sage: [1, -1] in RS</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CHECK_ERROR_MESSAGE</span> <span class="o">=</span> <span class="s1">&#39;Expected valid index (a tuple of </span><span class="si">{base}</span><span class="s1"> elements, where every partial sum is nonnegative and every total sum is 0), but instead received </span><span class="si">{seq}</span><span class="s1">.&#39;</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns ``True`` if and only if ``seq`` is a valid raising sequence.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: RS = RaisingSequenceSpace()</span>
<span class="sd">            sage: (1, -1) in RS</span>
<span class="sd">            True</span>
<span class="sd">            sage: (1, 0, -1) in RS</span>
<span class="sd">            True</span>
<span class="sd">            sage: (1, -1, 0, 9) in RS</span>
<span class="sd">            False</span>
<span class="sd">            sage: [1, -1] in RS</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check that it is a shifting sequence</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ShiftingSequenceSpace</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># check that every partial sum is nonnegative</span>
        <span class="n">partial_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
            <span class="n">partial_sum</span> <span class="o">+=</span> <span class="n">term</span>
            <span class="k">if</span> <span class="n">partial_sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># check that total sum is 0</span>
        <span class="k">if</span> <span class="n">partial_sum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># finally, succeed</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="ShiftingOperatorAlgebra"><a class="viewcode-back" href="../all.html#all.ShiftingOperatorAlgebra">[docs]</a><span class="k">class</span> <span class="nc">ShiftingOperatorAlgebra</span><span class="p">(</span><span class="n">CombinatorialFreeModule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An algebra of shifting operators.</span>

<span class="sd">    We follow the following convention:</span>

<span class="sd">    S[(1, 0, -1, 2)] is the shifting operator that raises the first part by 1, lowers the third part by 1, and raises the fourth part by 2.</span>

<span class="sd">    OPTIONAL ARGUMENTS:</span>

<span class="sd">    - ``base_ring`` -- (default ``QQ[&#39;t&#39;]``) the ring you will use on the raising operators.</span>

<span class="sd">    - ``prefix`` -- (default ``&quot;R&quot;``) the label for the raising operators.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">        sage: s = SymmetricFunctions(QQ[&#39;t&#39;]).s()</span>
<span class="sd">        sage: h = SymmetricFunctions(QQ[&#39;t&#39;]).h()</span>

<span class="sd">        sage: S[(1, -1, 2)]</span>
<span class="sd">        S(1, -1, 2)</span>
<span class="sd">        sage: S[(1, -1, 2)](s[5, 4])</span>
<span class="sd">        s[6, 3, 2]</span>
<span class="sd">        sage: S[(1, -1, 2)](h[5, 4])</span>
<span class="sd">        h[6, 3, 2]</span>

<span class="sd">        sage: (1 - S[(1,-1)]) * (1 - S[(4,)])</span>
<span class="sd">        S() - S(1, -1) - S(4,) + S(5, -1)</span>
<span class="sd">        sage: ((1 - S[(1,-1)]) * (1 - S[(4,)]))(s[2, 2, 1])</span>
<span class="sd">        s[2, 2, 1] - s[3, 1, 1] - s[6, 2, 1] + s[7, 1, 1]</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :class:`RaisingOperatorAlgebra`, :class:`PieriOperatorAlgebra`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">basis_indices</span><span class="o">=</span><span class="n">ShiftingSequenceSpace</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">base_ring</span>
        <span class="c1"># a single basis index looks like (1, 0, -1, 2), for example</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_indices</span> <span class="o">=</span> <span class="n">basis_indices</span>
        <span class="c1"># category</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="o">.</span><span class="n">category</span><span class="p">())</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">category</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="c1"># init</span>
        <span class="n">CombinatorialFreeModule</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basis_indices</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">,</span>
            <span class="n">bracket</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the shifting operator whose index is ``seq``.</span>

<span class="sd">        This method is only for basis indices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">            sage: S[1, 1, -9]</span>
<span class="sd">            S(1, 1, -9)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># seq should be a basis index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_indices</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">seq</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the shifting operator whose index is ``seq``.</span>

<span class="sd">        This method is only for basis indices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">            sage: S._element_constructor_([1, 1, -9])</span>
<span class="sd">            S(1, 1, -9)</span>
<span class="sd">            sage: S[1, 1, -9]</span>
<span class="sd">            S(1, 1, -9)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

<div class="viewcode-block" id="ShiftingOperatorAlgebra.one_basis"><a class="viewcode-back" href="../all.html#all.ShiftingOperatorAlgebra.one_basis">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">one_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the index of the identity element.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">            sage: S.one_basis()</span>
<span class="sd">            ()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return a string describing ``self`` to humans.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">            sage: S</span>
<span class="sd">            Shifting Operator Algebra over Univariate Polynomial Ring in t over Rational Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Shifting Operator Algebra over </span><span class="si">{base_ring}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">)</span>

<div class="viewcode-block" id="ShiftingOperatorAlgebra.product_on_basis"><a class="viewcode-back" href="../all.html#all.ShiftingOperatorAlgebra.product_on_basis">[docs]</a>    <span class="k">def</span> <span class="nf">product_on_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given indices ``index1`` and ``index2``, return the product of the basis elements indexed by those indices.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">            sage: S.product_on_basis([1, 1], [0, 1, 2])</span>
<span class="sd">            S(1, 2, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pad with 0&#39;s</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">index2</span><span class="p">))</span>
        <span class="n">index1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">index1</span><span class="p">))</span>
        <span class="n">index2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">index2</span><span class="p">))</span>
        <span class="c1"># add the vectors</span>
        <span class="n">index_product</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span> <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index_product</span><span class="p">)</span></div>

<div class="viewcode-block" id="ShiftingOperatorAlgebra.Element"><a class="viewcode-back" href="../all.html#all.ShiftingOperatorAlgebra.Element">[docs]</a>    <span class="k">class</span> <span class="nc">Element</span><span class="p">(</span><span class="n">CombinatorialFreeModule</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An element of a :class`ShiftingOperatorAlgebra`. &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ShiftingOperatorAlgebra.Element.indices"><a class="viewcode-back" href="../all.html#all.ShiftingOperatorAlgebra.Element.indices">[docs]</a>        <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the support of ``self``.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">                sage: (S[2, 1] + S[1, 1]).indices()</span>
<span class="sd">                [(1, 1), (2, 1)]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">()</span></div>

<div class="viewcode-block" id="ShiftingOperatorAlgebra.Element.index"><a class="viewcode-back" href="../all.html#all.ShiftingOperatorAlgebra.Element.index">[docs]</a>        <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the index of ``self``.</span>

<span class="sd">            This method is only for basis elements.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">                sage: S[2, 1].index()</span>
<span class="sd">                (2, 1)</span>
<span class="sd">                sage: (S[2, 1] + S[1, 1]).index()</span>
<span class="sd">                Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">                ValueError: This is only defined for basis elements.  For other elements, use indices() instead.</span>
<span class="sd">         &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;This is only defined for basis elements.  For other elements, use indices() instead.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

        <span class="k">def</span> <span class="nf">_call_basis_on_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; For internal use only!</span>

<span class="sd">            Return the action of the basis element indexed by ``seq`` upon the composition ``index``.</span>

<span class="sd">            INPUTS:</span>

<span class="sd">            - ``seq`` -- The sequence of the basis element that acts.</span>

<span class="sd">            - ``index`` -- A sequence (typically a composition or a partition) that we act upon.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: S = ShiftingOperatorAlgebra()</span>
<span class="sd">                sage: S[2, 1]._call_basis_on_index([1, 1], [1, 2, 3, 4, 5])</span>
<span class="sd">                [2, 3, 3, 4, 5]</span>

<span class="sd">            ..  SEEALSO::</span>
<span class="sd">                :meth:`__call__`</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="c1"># pad sequence and index with 0&#39;s</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
            <span class="c1"># raise and drop</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">seq</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">):</span>
            <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the action of this shifting operator element on the index ``operand``.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: S = ShiftingOperatorAlgebra()</span>

<span class="sd">                sage: S[2, 1]([1, 2, 3, 4])</span>
<span class="sd">                [([3, 3, 3, 4], 1)]</span>

<span class="sd">                sage: S[2, 1](([1, 2, 3, 4], [1, 1, 1]))</span>
<span class="sd">                ([([3, 3, 3, 4], 1)], [([3, 2, 1], 1)])</span>

<span class="sd">                sage: Sym = SymmetricFunctions(QQ[&#39;t&#39;])</span>
<span class="sd">                sage: s = Sym.schur()</span>
<span class="sd">                sage: S[2, 1](s[4, 3, 2, 1])</span>
<span class="sd">                s[6, 4, 2, 1]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">def</span> <span class="nf">raise_func</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">operand</span><span class="p">):</span>
                <span class="c1"># seq is the index</span>
                <span class="k">if</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_basis_on_index</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># it&#39;s some symmetric function basis element</span>
                    <span class="n">parent_basis</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                    <span class="c1"># but does the base ring of the parent basis agree with the base ring of the operator algebra??</span>
                    <span class="c1"># process the vectors</span>
                    <span class="n">dic</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="c1"># occasionally a coefficient can show up (not cool, so consider the inclusion of coeff here a patch)</span>
                    <span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">out_composition</span> <span class="o">=</span> <span class="n">raise_func</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">composition</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">parent_basis</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span>
                            <span class="s1">&#39;SymmetricFunctionAlgebra_homogeneous_with_category&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;SymmetricFunctionAlgebra_elementary_with_category&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;SymmetricFunctionAlgebra_power_with_category&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;SymmetricFunctionAlgebra_witt_with_category&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;SymmetricFunctionAlgebra_schur_with_category&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;HallLittlewood_qp_with_category&#39;</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">straighten</span><span class="p">(</span><span class="n">parent_basis</span><span class="p">,</span> <span class="n">out_composition</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">parent_basis</span><span class="p">(</span><span class="n">out_composition</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">call_monomial</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">power</span><span class="p">):</span>
                    <span class="n">operand</span> <span class="o">=</span> <span class="n">raise_func</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
            <span class="c1"># start here</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="s1">&#39;_get_indices_for_index_operator&#39;</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">_get_indices_for_index_operator</span><span class="p">()</span>
                <span class="c1"># TODO: see if this works for TUPLES of indices.  This has only been tested for a single index.</span>
                <span class="n">new_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">_new_object_for_index_operator</span><span class="p">(</span><span class="n">new_indices</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># the operand is actually a tuple of operands, so perform __call__ on each piece</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operand</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
                <span class="c1"># the operand is some kind of composition</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">call_monomial</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the operand is a symmetric function</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># the operand looks like s[2, 1] + s[3], for example</span>
                    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">summand</span><span class="p">)</span> <span class="k">for</span> <span class="n">summand</span> <span class="ow">in</span> <span class="n">operand</span><span class="o">.</span><span class="n">terms</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">call_monomial</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
                    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">mon</span> <span class="k">for</span> <span class="n">mon</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">out_list</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RaisingOperatorAlgebra"><a class="viewcode-back" href="../all.html#all.RaisingOperatorAlgebra">[docs]</a><span class="k">class</span> <span class="nc">RaisingOperatorAlgebra</span><span class="p">(</span><span class="n">ShiftingOperatorAlgebra</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An algebra of raising operators.</span>

<span class="sd">    This class subclasses :class:`ShiftingOperatorAlgebra` and inherits the large majority of its functionality from there.</span>

<span class="sd">    We follow the following convention!:</span>

<span class="sd">    R[(1, 0, -1)] is the raising operator that raises the first part by 1 and lowers the third part by 1.</span>

<span class="sd">    For a definition of raising operators, see [cat]_ Definition 2.1, but be wary that the notation is different there.  See :meth:`ij` for a way to create operators using the notation in the paper.</span>

<span class="sd">    If you do NOT want any restrictions on the allowed sequences, use :class:`ShiftingOperatorAlgebra` instead of :class:`RaisingOperatorAlgebra`.</span>

<span class="sd">    OPTIONAL ARGUMENTS:</span>

<span class="sd">    - ``base_ring`` -- (default ``QQ[&#39;t&#39;]``) the ring you will use on the raising operators.</span>

<span class="sd">    - ``prefix`` -- (default ``&quot;R&quot;``) the label for the raising operators.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: R = RaisingOperatorAlgebra()</span>
<span class="sd">        sage: s = SymmetricFunctions(QQ[&#39;t&#39;]).s()</span>
<span class="sd">        sage: h = SymmetricFunctions(QQ[&#39;t&#39;]).h()</span>

<span class="sd">        sage: R[(1, -1)]</span>
<span class="sd">        R(1, -1)</span>
<span class="sd">        sage: R[(1, -1)](s[5, 4])</span>
<span class="sd">        s[6, 3]</span>
<span class="sd">        sage: R[(1, -1)](h[5, 4])</span>
<span class="sd">        h[6, 3]</span>

<span class="sd">        sage: (1 - R[(1,-1)]) * (1 - R[(0,1,-1)])</span>
<span class="sd">        R() - R(0, 1, -1) - R(1, -1) + R(1, 0, -1)</span>
<span class="sd">        sage: ((1 - R[(1,-1)]) * (1 - R[(0,1,-1)]))(s[2, 2, 1])</span>
<span class="sd">        (-3*t-2)*s[] + s[2, 2, 1] - s[3, 1, 1] + s[3, 2]</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :class:`ShiftingOperatorAlgebra`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="p">):</span>
        <span class="n">ShiftingOperatorAlgebra</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span>
                                         <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
                                         <span class="n">basis_indices</span><span class="o">=</span><span class="n">RaisingSequenceSpace</span><span class="p">())</span>

<div class="viewcode-block" id="RaisingOperatorAlgebra.ij"><a class="viewcode-back" href="../all.html#all.RaisingOperatorAlgebra.ij">[docs]</a>    <span class="k">def</span> <span class="nf">ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the raising operator `R_{ij}` as notated in [cat]_ Definition 2.1.</span>

<span class="sd">        Shorthand element constructor that allows you to create raising operators using the familiar `R_{ij}` notation found in [cat]_ Definition 2.1, with the exception that indices here are 0-based, not 1-based.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Create the raising operator which raises part 0 and lowers part 2 (indices are 0-based)::</span>

<span class="sd">            sage: R.ij(0, 2)</span>
<span class="sd">            R((1, 0, -1))</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`ShiftingOperatorAlgebra._element_constructor_`, :meth:`ShiftingOperatorAlgebra.__getitem__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;i must be a natural number.  You input i = </span><span class="si">{i}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;j must be a natural number.  You input j = </span><span class="si">{j}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Index j must be greater than index i.  You input (i, j) = (</span><span class="si">{i}</span><span class="s1">, </span><span class="si">{j}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">))</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_constructor_</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PieriOperatorAlgebra"><a class="viewcode-back" href="../all.html#all.PieriOperatorAlgebra">[docs]</a><span class="k">class</span> <span class="nc">PieriOperatorAlgebra</span><span class="p">(</span><span class="n">ShiftingOperatorAlgebra</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The Pieri operator `u_i`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: u = PieriOperatorAlgebra()</span>

<span class="sd">    Act on catalan function::</span>

<span class="sd">        sage: cf = CatalanFunction([(0,2), (1,2)], [6, 6, 6])</span>
<span class="sd">        sage: u.i(2)(cf)</span>
<span class="sd">        CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>

<span class="sd">    Act on k-schur function::</span>

<span class="sd">        sage: base_ring = QQ[&#39;t&#39;]</span>
<span class="sd">        sage: Sym = SymmetricFunctions(base_ring)</span>
<span class="sd">        sage: t = base_ring.gen()</span>
<span class="sd">        sage: ks = Sym.kBoundedSubspace(4, t).kschur()</span>
<span class="sd">        sage: u.i(2)(ks[2, 2, 1])</span>
<span class="sd">        ks4[2, 2, 1] + t^2*ks4[3, 2] + t^3*ks4[4, 1]</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :class:`ShiftingOperatorAlgebra`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: verify by hand that above is really correct, or maybe a simpler example</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">):</span>
        <span class="n">ShiftingOperatorAlgebra</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span>
                                         <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
                                         <span class="n">basis_indices</span><span class="o">=</span><span class="n">ShiftingSequenceSpace</span><span class="p">())</span>

<div class="viewcode-block" id="PieriOperatorAlgebra.i"><a class="viewcode-back" href="../all.html#all.PieriOperatorAlgebra.i">[docs]</a>    <span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the Pieri operator `u_i`.</span>

<span class="sd">        Shorthand element constructor that allows you to create Pieri operators using the familiar `u_i` notation, with the exception that indices here are 0-based, not 1-based.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        Create the Pieri operator which lowers part 2 (indices are 0-based)::</span>

<span class="sd">            sage: u.i(2)</span>
<span class="sd">            u((0, 0, -1))</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`ShiftingOperatorAlgebra._element_constructor_`, :meth:`ShiftingOperatorAlgebra.__getitem__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;i must be a natural number.  You input i = </span><span class="si">{i}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_constructor_</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span></div>

    <span class="k">class</span> <span class="nc">Element</span><span class="p">(</span><span class="n">ShiftingOperatorAlgebra</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">):</span>
            <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return the action of this raising operator element on the index ``operand``.</span>

<span class="sd">            EXAMPLES::</span>

<span class="sd">                sage: R = RaisingOperatorAlgebra()</span>

<span class="sd">                sage: R[1, -1]([1, 2, 3, 4])</span>
<span class="sd">                [([2, 1, 3, 4], 1)]</span>

<span class="sd">                sage: R[1, -1](([1, 2, 3, 4], [1, 1, 1]))</span>
<span class="sd">                ([([2, 1, 3, 4], 1)], [([2, 0, 1], 1)])</span>

<span class="sd">                sage: Sym = SymmetricFunctions(QQ[&#39;t&#39;])</span>
<span class="sd">                sage: s = Sym.schur()</span>
<span class="sd">                sage: R[1, -1](s[4, 3, 2, 1])</span>
<span class="sd">                s[5, 2, 2, 1]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">_is_k_schur</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
                <span class="c1"># convert to catalans</span>
                <span class="n">kschur</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
                <span class="n">base_ring</span> <span class="o">=</span> <span class="n">kschur</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
                <span class="n">cat_coeff_pairs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">CatalanFunctions</span><span class="p">()</span><span class="o">.</span><span class="n">init_from_k_schur</span><span class="p">(</span>
                        <span class="n">kschur</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">),</span> <span class="n">coeff</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">operand</span><span class="p">]</span>
                <span class="c1"># act</span>
                <span class="n">new_cat_coeff_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">cat</span><span class="p">),</span> <span class="n">coeff</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">cat</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">cat_coeff_pairs</span><span class="p">]</span>
                <span class="c1"># convert back to kschur</span>
                <span class="n">out_coeff_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">kschur</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">eval</span><span class="p">()),</span> <span class="n">coeff</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">cat</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">cat_coeff_pairs</span><span class="p">]</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">func</span> <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">out_coeff_pairs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ShiftingOperatorAlgebra</span><span class="o">.</span><span class="n">Element</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span></div>


<div class="viewcode-block" id="HallLittlewoodVertexOperator"><a class="viewcode-back" href="../all.html#all.HallLittlewoodVertexOperator">[docs]</a><span class="k">class</span> <span class="nc">HallLittlewoodVertexOperator</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The Hall-Littlewood vertex operator.</span>

<span class="sd">    Garsia&#39;s version of Jing&#39;s Hall-Littlewood vertex operators.  These are defined in equations 4.2 and 4.3 of [cat]_ and appear visually as a bold capital H.</span>

<span class="sd">    INPUTS:</span>

<span class="sd">    - ``base_ring`` -- (default ``QQ[&#39;t&#39;]``) the base ring to build the :class:`SymmetricFunctions` upon.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: H = HallLittlewoodVertexOperator</span>
<span class="sd">        sage: one = SymmetricFunctions(QQ[&#39;t&#39;]).hall_littlewood().Qp().one()</span>
<span class="sd">        sage: H([4, 1, 3])(one) == H(4)(H(1)(H(3)(one)))</span>
<span class="sd">        True</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`sage.combinat.sf.new_kschur.KBoundedSubspaceBases.ElementMethods.hl_creation_operator`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">composition</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">composition</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">([</span><span class="n">composition</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">composition</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">composition</span> <span class="o">=</span> <span class="n">Composition</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad composition.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span> <span class="o">=</span> <span class="n">base_ring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return a human-friendly string representation of this Hall-Littlewood vertex operator.</span>

<span class="sd">        This string also serves as an example of what somebody might type to create this Hall-Littlewood vertex operator in sage.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: H = HallLittlewoodVertexOperator</span>
<span class="sd">            sage: H([4, 1, 3])</span>
<span class="sd">            HallLittlewoodVertexOperator([4, 1, 3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        Return the homogeneous function indexed by the integer ``k``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: op = HallLittlewoodVertexOperator([4, 1, 3])</span>
<span class="sd">            sage: op._hh(-2)</span>
<span class="sd">            0</span>
<span class="sd">            sage: op._hh(-1)</span>
<span class="sd">            0</span>
<span class="sd">            sage: op._hh(0)</span>
<span class="sd">            s[]</span>
<span class="sd">            sage: op._hh(1)</span>
<span class="sd">            s[1]</span>
<span class="sd">            sage: op._hh(2)</span>
<span class="sd">            s[2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># homogeneous indexed by an integer k (positive or negative)</span>
        <span class="c1"># if k is less than 0, result is 0</span>
        <span class="c1"># if k == 0, result is s([])</span>
        <span class="c1"># if k &gt; 0, then the result is s([k])</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 0, but as a sym func</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">([</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">def</span> <span class="nf">_skewbyeeq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        Given integer ``k`` and function ``f``, return the function `f` skewed by e[k](1-t).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># skew by e[k](1-t)</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 0, but as a sym func</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">f</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">e</span><span class="p">([</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">def</span> <span class="nf">_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        This method is Jing&#39;s Hall-Littlewood creation operator.</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`sage.combinat.sf.new_kschur.KBoundedSubspaceBases.ElementMethods.hl_creation_operator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hh</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skewbyeeq</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the action of this Hall-Littlewood operator on ``input_``.</span>

<span class="sd">        INPUTS:</span>

<span class="sd">        - ``input_`` -- A symmetric function.</span>

<span class="sd">        EXAMPLES:</span>

<span class="sd">        We typically act on the identity, so let&#39;s retrieve the identity::</span>

<span class="sd">            sage: Sym = SymmetricFunctions(QQ[&#39;t&#39;])</span>
<span class="sd">            sage: hl = Sym.hall_littlewood().Qp()</span>
<span class="sd">            sage: one = hl.one()</span>

<span class="sd">        Let&#39;s look at the action of `H_{4, 1, 3}` on the identity::</span>

<span class="sd">            sage: H = HallLittlewoodVertexOperator</span>
<span class="sd">            sage: H([4, 1, 3])(one)</span>
<span class="sd">            (t-1)*HLQp[4, 2, 2] + t*HLQp[4, 3, 1]</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`sage.combinat.sf.new_kschur.KBoundedSubspaceBases.ElementMethods.hl_creation_operator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">HLQp</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">HLQp</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">)</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
        <span class="c1"># iterate</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">gamma</span><span class="p">):</span>
            <span class="n">input_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">input_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">HLQp</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span></div>


<div class="viewcode-block" id="compositional_hall_littlewood_Qp"><a class="viewcode-back" href="../all.html#all.compositional_hall_littlewood_Qp">[docs]</a><span class="k">def</span> <span class="nf">compositional_hall_littlewood_Qp</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given gamma, returns the compositional Hall-Littlewood polynomial `H_{\gamma}(\mathbf{x}; t)` in the Q&#39; basis, as defined in [cat]_ section 4.4.</span>

<span class="sd">    If the composition gamma is a partition, this is just the Hall-Littlewood Q&#39; polynomial.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: hl = SymmetricFunctions(QQ[&#39;t&#39;]).hall_littlewood().Qp()</span>
<span class="sd">        sage: compositional_hall_littlewood_Qp([3, 3, 2]) == hl[3, 3, 2]</span>
<span class="sd">        True</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`sage.combinat.sf.hall_littlewood.HallLittlewood.Qp`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">HLQp</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">HLQp</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">is_weakly_decreasing</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">term</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">gamma</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="n">gamma</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># this is MUCH faster than the HallLittlewoodVertexOperator for partitions of length 5ish</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">HLQp</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">HallLittlewoodVertexOperator</span>
        <span class="k">return</span> <span class="n">H</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)(</span><span class="n">HLQp</span><span class="o">.</span><span class="n">one</span><span class="p">())</span></div>

<div class="viewcode-block" id="raising_roots_operator"><a class="viewcode-back" href="../all.html#all.raising_roots_operator">[docs]</a><span class="k">def</span> <span class="nf">raising_roots_operator</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the operator `\prod_{(i,j) \in roots} (1 - tR_{ij})`.</span>

<span class="sd">    Given a list of roots `roots = \Phi` (often a root ideal), and optionally a variable `t`, return the operator</span>

<span class="sd">    ..  MATH::</span>

<span class="sd">        \prod_{(i,j) \in \Phi} (1 - tR_{ij}).</span>

<span class="sd">    If you input an integer for roots (e.g. ``roots = 3``), it will use the biggest possible root ideal in the `n` x `n` grid (the &#39;`n`-th staircase root ideal&#39;).</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    Consider the root ideal [(0, 1)] in the 2 x 2 grid.  This root ideal gives the raising roots operator `1 - R_{01}`::</span>

<span class="sd">        sage: R = RaisingOperatorAlgebra()</span>
<span class="sd">        sage: 1 - R.ij(0, 1)</span>
<span class="sd">        R() - R(1, -1)</span>

<span class="sd">        sage: raising_roots_operator([(0, 1)])</span>
<span class="sd">        R() - R(1, -1)</span>

<span class="sd">        sage: raising_roots_operator(2)</span>
<span class="sd">        R() - R(1, -1)</span>

<span class="sd">    We can pass in `t` in addition to get the raising roots operator `1 - t R_{01}`.  We can also choose a base ring to work over::</span>

<span class="sd">        sage: K = FractionField(ZZ[&#39;t&#39;])</span>
<span class="sd">        sage: t = K.gen()</span>
<span class="sd">        sage: R = RaisingOperatorAlgebra(base_ring=K)</span>

<span class="sd">        sage: 1 - t * R.ij(0, 1)</span>
<span class="sd">        R() - t*R(1, -1)</span>

<span class="sd">        sage: raising_roots_operator([(0, 1)], base_ring=K, t=t)</span>
<span class="sd">        R() - t*R(1, -1)</span>

<span class="sd">        sage: raising_roots_operator(2, base_ring=K, t=t)</span>
<span class="sd">        R() - t*R(1, -1)</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`qt_raising_roots_operator`, :class:`CatalanFunction`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">RaisingOperatorAlgebra</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">roots</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">():</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">RootIdeals</span><span class="p">()</span><span class="o">.</span><span class="n">init_staircase</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">prod</span><span class="p">([</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">ij</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">],</span> <span class="n">R</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">op</span></div>


<div class="viewcode-block" id="qt_raising_roots_operator"><a class="viewcode-back" href="../all.html#all.qt_raising_roots_operator">[docs]</a><span class="k">def</span> <span class="nf">qt_raising_roots_operator</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the operator `\prod_{ij \in \Phi} (1 - tR_{ij}) \prod_{ij \in roots} (1 - qR_{ij})`.</span>

<span class="sd">    The q-t analogue of :meth:`raising_roots_operator`, defined by</span>

<span class="sd">    ..  MATH::</span>
<span class="sd">        \prod_{ij \in \Phi} (1 - tR_{ij}) \prod_{ij \in \Phi} (1 - qR_{ij}).</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    Consider the root ideal [(0, 1)] in the 2 x 2 grid.  This root ideal gives the &quot;qt&quot; raising roots operator `(1 - t R_{01})(1 - q R_{01})` which equals `1 + (-t-q) R_{01} + t q R_{01}^2`::</span>

<span class="sd">        sage: K = QQ[&#39;t&#39;, &#39;q&#39;]</span>
<span class="sd">        sage: (t, q) = K.gens()</span>
<span class="sd">        sage: R = RaisingOperatorAlgebra(base_ring=K)</span>

<span class="sd">        sage: (1 - t*R.ij(0, 1)) * (1 - q*R.ij(0, 1))</span>
<span class="sd">        R() + (-t-q)*R(1, -1) + t*q*R(2, -2)</span>

<span class="sd">        sage: qt_raising_roots_operator([(0, 1)], base_ring=K, t=t, q=q)</span>
<span class="sd">        R() + (-t-q)*R(1, -1) + t*q*R(2, -2)</span>

<span class="sd">    Since ``QQ[&#39;t&#39;, &#39;q&#39;]`` happens to be the default base ring, and its generators are ``t`` and ``q``, we did not actually need to pass in the base ring, `t`, nor `q` in the above example::</span>

<span class="sd">        sage: qt_raising_roots_operator([(0, 1)])</span>
<span class="sd">        R() + (-t-q)*R(1, -1) + t*q*R(2, -2)</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`raising_roots_operator`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">roots</span> <span class="ow">in</span> <span class="n">NonNegativeIntegerSemiring</span><span class="p">():</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">RootIdeals</span><span class="p">()</span><span class="o">.</span><span class="n">init_staircase</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">base_ring</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">base_ring</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">op1</span> <span class="o">=</span> <span class="n">raising_roots_operator</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>
    <span class="n">op2</span> <span class="o">=</span> <span class="n">raising_roots_operator</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op2</span> <span class="o">*</span> <span class="n">op1</span></div>


<div class="viewcode-block" id="CatalanFunction"><a class="viewcode-back" href="../all.html#all.CatalanFunction">[docs]</a><span class="k">class</span> <span class="nc">CatalanFunction</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A catalan function `H(\Psi; \gamma)` as discussed in [cat]_ section 4.</span>

<span class="sd">    By definition,</span>

<span class="sd">    ..  MATH::</span>

<span class="sd">        H(\Psi; \gamma) := \prod_{ij \in \Psi} (1 - R_{ij})^{-1} s_\gamma = \prod_{ij \in \Delta^+ \smallsetminus \Psi} (1 - R_{ij}) H_\gamma</span>

<span class="sd">    where `s_\gamma` is a schur function and `H_\gamma` is a Hall-Littlewood Q&#39; function.</span>

<span class="sd">    The parameters for initializing a catalan function are exactly the same as in :meth:`CatalanFunctions.init_from_indexed_root_ideal`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">        H([(0, 2), (1, 2)]; [6, 6, 5])</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        There are more ways to initialize a catalan function, and the methods for doing so are found in :class:`CatalanFunctions`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BASE_RING_DEFAULT</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
    <span class="n">PREFIX_DEFAULT</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">assert</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">_is_roots</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="o">=</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span> <span class="o">=</span> <span class="n">base_ring</span> <span class="k">if</span> <span class="n">base_ring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">BASE_RING_DEFAULT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">PREFIX_DEFAULT</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return whether this catalan function is equal to the catalan function ``other``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cf1 = CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            sage: cf2 = CatalanFunction({(1,2), (0,2)}, Partition([6, 6, 5]))</span>
<span class="sd">            sage: cf1 == cf2</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: account for the fact that DIFFERENT root/index pairs could actually give the SAME catalan function!!</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">roots</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">base_ring</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return a human-friendly string representation of this catalan function.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cf = CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            sage: cf</span>
<span class="sd">            H([(0, 2), (1, 2)]; [6, 6, 5])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_indices_for_index_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        This method is defined so that an element of any :class:`ShiftingOperatorAlgebra` (such as a raising operator or a pieri operator) can act on this catalan function.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cf = CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            sage: cf._get_indices_for_index_operator()</span>
<span class="sd">            [6, 6, 5]</span>

<span class="sd">        This is what allows you to do something like::</span>

<span class="sd">            sage: cf = CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            sage: R = RaisingOperatorAlgebra()</span>
<span class="sd">            sage: R.ij(0, 1)(cf)</span>
<span class="sd">            H([(0, 2), (1, 2)]; [7, 5, 5])</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`_new_object_for_index_operator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

    <span class="k">def</span> <span class="nf">_new_object_for_index_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_index</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        This method is defined so that an element of any :class:`ShiftingOperatorAlgebra` (such as a raising operator or a pieri operator) can act on this catalan function.</span>

<span class="sd">        Returns a brand new :class:`CatalanFunction`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cf = CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            sage: cf._new_object_for_index_operator([7, 5, 5])</span>
<span class="sd">            H([(0, 2), (1, 2)]; [7, 5, 5])</span>

<span class="sd">        This is what allows you to do something like::</span>

<span class="sd">            sage: cf = CatalanFunction([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            sage: R = RaisingOperatorAlgebra()</span>
<span class="sd">            sage: R.ij(0, 1)(cf)</span>
<span class="sd">            H([(0, 2), (1, 2)]; [7, 5, 5])</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`_get_indices_for_index_operator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="p">,</span> <span class="n">new_index</span><span class="p">,</span>
                                 <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_obj</span>

<div class="viewcode-block" id="CatalanFunction.eval"><a class="viewcode-back" href="../all.html#all.CatalanFunction.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the catalan function in terms of the Hall-Littlewood Q&#39; basis.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: delta_plus = partition_to_root_ideal([2, 1], n=3)</span>
<span class="sd">            sage: cf = CatalanFunction(delta_plus, [3, 1, 1])</span>
<span class="sd">            sage: cf.eval()</span>
<span class="sd">            HLQp[3, 1, 1]</span>

<span class="sd">            sage: s = SymmetricFunctions(QQ[&#39;t&#39;]).schur()</span>
<span class="sd">            sage: cf = CatalanFunction([], [4, 1])</span>
<span class="sd">            sage: cf.eval()</span>
<span class="sd">            HLQp[4, 1] - t*HLQp[5]</span>
<span class="sd">            sage: s(cf.eval())</span>
<span class="sd">            s[4, 1]</span>

<span class="sd">        This function can also specialize `t` to an arbitrary integer::</span>

<span class="sd">            sage: cf.eval(t=1)</span>
<span class="sd">            HLQp[4, 1] - HLQp[5]</span>
<span class="sd">            sage: cf.eval(t=-1)</span>
<span class="sd">            HLQp[4, 1] + HLQp[5]</span>
<span class="sd">            sage: s(cf.eval(t=-1))</span>
<span class="sd">            s[4, 1]</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`expand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># setup</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hl</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">)</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hl</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">)</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
        <span class="c1"># formula</span>
        <span class="n">roots_complement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">raising_roots_operator</span><span class="p">(</span>
            <span class="n">roots_complement</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
        <span class="n">hl_poly</span> <span class="o">=</span> <span class="n">hl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">cat_func</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">hl_poly</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cat_func</span></div>

<div class="viewcode-block" id="CatalanFunction.expand"><a class="viewcode-back" href="../all.html#all.CatalanFunction.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the catalan function as a symmetric polynomial in ``n`` variables.</span>

<span class="sd">        INPUT:</span>

<span class="sd">        - ``n`` -- a nonnegative integer</span>

<span class="sd">        - ``alphabet`` -- (default: ``&#39;x&#39;``) a variable for the expansion</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">        A monomial expansion of ``self`` in the `n` variables</span>
<span class="sd">        labelled ``x0``, ``x1``, ..., ``x{n-1}`` (or just ``x``</span>
<span class="sd">        if `n = 1`), where ``x`` is ``alphabet``.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: cf = CatalanFunction([], [4, 1])</span>
<span class="sd">            sage: cf.expand(1)</span>
<span class="sd">            0</span>
<span class="sd">            sage: cf.expand(2)</span>
<span class="sd">            x0^4*x1 + x0^3*x1^2 + x0^2*x1^3 + x0*x1^4</span>
<span class="sd">            sage: cf.expand(2, alphabet=&#39;y&#39;)</span>
<span class="sd">            y0^4*y1 + y0^3*y1^2 + y0^2*y1^3 + y0*y1^4</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`eval`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CatalanFunctions"><a class="viewcode-back" href="../all.html#all.CatalanFunctions">[docs]</a><span class="k">class</span> <span class="nc">CatalanFunctions</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The family of catalan functions, as discussed in [cat]_ section 4.</span>

<span class="sd">    Use this class as a factory to initialize a :class:`CatalanFunction` object with any valid identifying data.  See the ``init_from...`` methods below for all possible ways to create a catalan function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CatalanFunctions.init_from_indexed_root_ideal"><a class="viewcode-back" href="../all.html#all.CatalanFunctions.init_from_indexed_root_ideal">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_indexed_root_ideal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUTS:</span>

<span class="sd">        - ``roots`` -- iterable of roots `\Phi` (typically a root ideal)</span>

<span class="sd">        - ``index`` -- composition `\gamma` that indexes the root ideal and appears in `s_\gamma` and `H_\gamma` below</span>

<span class="sd">        OPTIONAL INPUTS:</span>

<span class="sd">        - ``base_ring`` -- (default ``QQ[&#39;t&#39;]``) the ring over which to build the `h_\gamma(x; \alpha)`&#39;s</span>

<span class="sd">        OUTPUTS:</span>

<span class="sd">        The catalan function</span>

<span class="sd">        ..  MATH::</span>

<span class="sd">            H(\Phi; \gamma) := \prod_{ij \in \Phi} (1 - R_{ij})^{-1} s_\gamma = \prod_{ij \in \Delta^+ \smallsetminus \Phi} (1 - R_{ij}) H_\gamma</span>

<span class="sd">        where `s_\gamma` is a schur function and `H_\gamma` is a Hall-Littlewood Q&#39; function.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CatalanFunctions().init_from_indexed_root_ideal([(0,2), (1,2)], [6, 6, 5])</span>
<span class="sd">            H([(0, 2), (1, 2)]; [6, 6, 5])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CatalanFunction</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="CatalanFunctions.init_from_skew_partition"><a class="viewcode-back" href="../all.html#all.CatalanFunctions.init_from_skew_partition">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_skew_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;removable roots&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a skew partition ``sp``, return the catalan function `H(\Phi^+(sp); rs(sp))`.</span>

<span class="sd">        Given a linked :class:`SkewPartition` ``sp``, return the :class:`CatalanFunction` `H(\Phi^+(sp); rs(sp))`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CFS = CatalanFunctions()</span>
<span class="sd">            sage: sp = SkewPartition([[2, 1, 1], [1]])</span>
<span class="sd">            sage: CFS.init_from_skew_partition(sp)</span>
<span class="sd">            H([(0, 1), (0, 2)]; [1, 1, 1])</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`init_from_row_and_column_lengths`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="n">RootIdeals</span><span class="p">()</span><span class="o">.</span><span class="n">init_from_skew_partition</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">)</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">row_lengths</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_indexed_root_ideal</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="CatalanFunctions.init_from_row_and_column_lengths"><a class="viewcode-back" href="../all.html#all.CatalanFunctions.init_from_row_and_column_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_row_and_column_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_lengths</span><span class="p">,</span> <span class="n">column_lengths</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;removable roots&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Determine the skew partition `D` with row-shape ``row_lengths`` and column-shape ``column_lengths``, and return the catalan function `H(\Phi^+(D); \text{row_lengths})`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CFS = CatalanFunctions()</span>
<span class="sd">            sage: CFS.init_from_row_and_column_lengths([1, 1, 1], [2, 1])</span>
<span class="sd">            H([(0, 1), (0, 2)]; [1, 1, 1])</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`init_from_skew_partition`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">SkewPartitions</span><span class="p">()</span><span class="o">.</span><span class="n">from_row_and_column_length</span><span class="p">(</span><span class="n">row_lengths</span><span class="p">,</span> <span class="n">column_lengths</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_skew_partition</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">)</span></div>

<div class="viewcode-block" id="CatalanFunctions.init_from_k_shape"><a class="viewcode-back" href="../all.html#all.CatalanFunctions.init_from_k_shape">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_k_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;removable roots&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given ``k`` and a `k`-shape ``p``, return the catalan function `H(\Phi^+(p); rs(p))`.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CFS = CatalanFunctions()</span>
<span class="sd">            sage: CFS.init_from_k_shape([4, 3, 2, 1], 1)</span>
<span class="sd">            H([]; [4, 3, 2, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">is_k_shape</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">SkewPartition</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="p">[]])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_skew_partition</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">)</span></div>

<div class="viewcode-block" id="CatalanFunctions.init_from_k_schur"><a class="viewcode-back" href="../all.html#all.CatalanFunctions.init_from_k_schur">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_k_schur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a `k`-schur function ``func`` `= s^k_\lambda(x;t)`, initialize the catalan function `H(\Delta^k(\lambda); \lambda)`.</span>

<span class="sd">        Mathematically, these two functions are equal.  The usefulness of this method is that you input a ``sage.combinat.sf.new_kschur.kSchur_with_category`` object and you obtain a :class:`CatalanFunction` object.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: base_ring = QQ[&#39;t&#39;]</span>
<span class="sd">            sage: Sym = SymmetricFunctions(base_ring)</span>
<span class="sd">            sage: t = base_ring.gen()</span>
<span class="sd">            sage: ks = Sym.kBoundedSubspace(4, t).kschur()</span>
<span class="sd">            sage: func = ks[2, 1, 1]</span>
<span class="sd">            sage: CatalanFunction(func, base_ring=base_ring)</span>
<span class="sd">            H([]; [2, 1, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: make sure [] above is correct.  go by hand.</span>
        <span class="c1"># check inputs</span>
        <span class="k">assert</span> <span class="n">_is_k_schur</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">support</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># gather roots</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">support</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">k</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">partition_to_k_schur_root_ideal</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="c1"># initialize from roots and index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_indexed_root_ideal</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span></div>

<div class="viewcode-block" id="CatalanFunctions.init_parabolic_from_composition_and_index"><a class="viewcode-back" href="../all.html#all.CatalanFunctions.init_parabolic_from_composition_and_index">[docs]</a>    <span class="k">def</span> <span class="nf">init_parabolic_from_composition_and_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a composition `\eta` of positive integers and an index `\gamma`, return the parabolic catalan function `H(\Delta(\eta), \gamma)`, where</span>

<span class="sd">        ..  math::</span>

<span class="sd">            \Delta(\eta) := \{ \alpha \in \Delta^+_{|\eta|} \:\text{above the block diagonal with block sizes}\: \eta_1, \ldots, \eta_r\}</span>

<span class="sd">        as in [cat]_ just below Conjecture 3.3.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: CatalanFunctions().init_parabolic_from_composition_and_index([1, 3, 2], [1, 2, 3, 4, 5, 6])</span>
<span class="sd">            H([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]; [1, 2, 3, 4, 5, 6])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ri</span> <span class="o">=</span> <span class="n">RootIdeals</span><span class="p">()</span><span class="o">.</span><span class="n">init_parabolic_from_composition</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_from_indexed_root_ideal</span><span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span></div></div>


<span class="c1">##############</span>
<div class="viewcode-block" id="k_plus_one_core_to_k_schur_function"><a class="viewcode-back" href="../all.html#all.k_plus_one_core_to_k_schur_function">[docs]</a><span class="k">def</span> <span class="nf">k_plus_one_core_to_k_schur_function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a `k+1`-core ``p``, the natural number ``k`` itself, and optionally a ``base_ring``, return the corresponding `k`-schur function. &quot;&quot;&quot;</span>
    <span class="c1"># TODO: compare the performance of this function to existing k-schur function.</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Core</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">k_shape_to_catalan_function</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">)</span></div>


<div class="viewcode-block" id="InfiniteDimensionalFreeAlgebra"><a class="viewcode-back" href="../all.html#all.InfiniteDimensionalFreeAlgebra">[docs]</a><span class="k">class</span> <span class="nc">InfiniteDimensionalFreeAlgebra</span><span class="p">(</span><span class="n">CombinatorialFreeModule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    By default, the algebra generated by ``x[0], x[1], x[2], ...`` over the integers.</span>

<span class="sd">    To change the index set of the generators, use ``index_set=`` (default ``NN``).  To overhaul the set of generators entirely (not recommended), use ``basis_indices=``.</span>

<span class="sd">    To change the ring that the algebra works over, use ``base_ring=`` (default ``ZZ``).</span>

<span class="sd">    To change the prefix of the generators, use ``prefix=`` (default ``&#39;x&#39;``).</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        sage.algebras.free_algebra, https://doc.sagemath.org/html/en/reference/monoids/sage/monoids/free_abelian_monoid.html, sage.monoids.free_monoid, sage.monoids.free_abelian_monoid</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">base_ring</span><span class="o">=</span><span class="n">IntegerRing</span><span class="p">(),</span>
                 <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
                 <span class="n">basis_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">index_set</span><span class="o">=</span><span class="n">NonNegativeIntegerSemiring</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span> <span class="o">=</span> <span class="n">base_ring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="o">=</span> <span class="n">index_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_monoid</span> <span class="o">=</span> <span class="n">FreeMonoid</span><span class="p">(</span>
            <span class="n">index_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span> <span class="k">if</span> <span class="n">basis_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">basis_indices</span>
        <span class="c1"># category</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">Algebras</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span><span class="o">.</span><span class="n">Commutative</span><span class="p">()</span>
        <span class="n">category</span> <span class="o">=</span> <span class="n">category</span><span class="o">.</span><span class="n">or_subcategory</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="c1"># init</span>
        <span class="n">CombinatorialFreeModule</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basis_monoid</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="n">bracket</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># TODO: make a SEPARATE class called InfiniteDimensionalFreeRing or similar</span>
        <span class="c1"># self._init_category_(CommutativeRings()) # i think .Commutative() above is a better solution</span>

<div class="viewcode-block" id="InfiniteDimensionalFreeAlgebra.is_prime_field"><a class="viewcode-back" href="../all.html#all.InfiniteDimensionalFreeAlgebra.is_prime_field">[docs]</a>    <span class="k">def</span> <span class="nf">is_prime_field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return whether the infinite dimensional free algebra is a prime field (it never is!).</span>

<span class="sd">        Note that this method exists for internal compatability.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: A = InfiniteDimensionalFreeAlgebra()</span>
<span class="sd">            sage: A.is_prime_field()</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_element_constructor_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monoid_el</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the element whose index is ``monoid_el``.</span>

<span class="sd">        Note: This method is only for basis elements.  This method for internal use.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`__getitem__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">monoid_el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_monoid</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">monoid_el</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_input</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given an integer ``user_input``, return the corresponding basis element.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: A = InfiniteDimensionalFreeAlgebra()</span>
<span class="sd">            sage: A[4]</span>
<span class="sd">            x[4]</span>

<span class="sd">        ..  SEEALSO::</span>
<span class="sd">            :meth:`_element_constructor_`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># USER front entrance to creating elements &quot;x[4]&quot;</span>
        <span class="k">assert</span> <span class="n">user_input</span> <span class="ow">in</span> <span class="n">IntegerRing</span><span class="p">()</span>
        <span class="n">monoid_el</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_monoid</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">user_input</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">monoid_el</span><span class="p">]</span>

<div class="viewcode-block" id="InfiniteDimensionalFreeAlgebra.one_basis"><a class="viewcode-back" href="../all.html#all.InfiniteDimensionalFreeAlgebra.one_basis">[docs]</a>    <span class="nd">@cached_method</span>
    <span class="k">def</span> <span class="nf">one_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the index of the identity element.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: A.one_basis()</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_monoid</span><span class="o">.</span><span class="n">one</span><span class="p">()</span></div>

<div class="viewcode-block" id="InfiniteDimensionalFreeAlgebra.product_on_basis"><a class="viewcode-back" href="../all.html#all.InfiniteDimensionalFreeAlgebra.product_on_basis">[docs]</a>    <span class="k">def</span> <span class="nf">product_on_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monoid_el1</span><span class="p">,</span> <span class="n">monoid_el2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given indices ``monoid_el1`` and ``monoid_el2``, return the product of the basis elements indexed by those indices.</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">monoid_el_product</span> <span class="o">=</span> <span class="n">monoid_el1</span> <span class="o">*</span> <span class="n">monoid_el2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element_constructor_</span><span class="p">(</span><span class="n">monoid_el_product</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return a human-friendly string representation of this infinite-dimensional free algebra.</span>

<span class="sd">        EXAMPLES::</span>

<span class="sd">            sage: F = InfiniteDimensionalFreeAlgebra()</span>
<span class="sd">            sage: F</span>
<span class="sd">            InfiniteDimensionalFreeAlgebra_with_category with generators indexed by Non negative integer semiring, over Integer Ring</span>

<span class="sd">            sage: F = InfiniteDimensionalFreeAlgebra(base_ring=QQ, index_set=ZZ)</span>
<span class="sd">            sage: F</span>
<span class="sd">            InfiniteDimensionalFreeAlgebra_with_category with generators indexed by Integer Ring, over Rational Field</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{class_name}</span><span class="s2"> with generators indexed by </span><span class="si">{index_set}</span><span class="s2">, over </span><span class="si">{base_ring}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_ring</span><span class="p">,</span> <span class="n">index_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="p">)</span></div>


<span class="n">DoubleRing</span> <span class="o">=</span> <span class="n">InfiniteDimensionalFreeAlgebra</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">index_set</span><span class="o">=</span><span class="n">IntegerRing</span><span class="p">())</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot; ``DoubleRing`` is the ring `\Lambda(a)` found in [Fun]_ section 3.</span>

<span class="sd">EXAMPLES::</span>

<span class="sd">    sage: DoubleRing</span>
<span class="sd">    InfiniteDimensionalFreeAlgebra_with_category with generators indexed by Integer Ring, over Integer Ring</span>

<span class="sd">..  SEEALSO::</span>
<span class="sd">    :class:`InfiniteDimensionalFreeAlgebra`</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="dual_k_theoretic_homogeneous"><a class="viewcode-back" href="../all.html#all.dual_k_theoretic_homogeneous">[docs]</a><span class="k">def</span> <span class="nf">dual_k_theoretic_homogeneous</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The dual K-theoretic h, often denoted Kh, is defined for any integer `k` by the formula `h_k(x, r) = \sum_{i=0}^{k} \binom{r + i - 1}{i} h_{k - i}(x)` in [LN]_ p.88 top-right.</span>

<span class="sd">    If ``k`` and ``r`` are compositions, then it is recursively defined as `h_k(x, r) := \prod_j h_{k_j}(x, r_j)`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: dual_k_theoretic_homogeneous(0, 0)</span>
<span class="sd">        1</span>

<span class="sd">        sage: dual_k_theoretic_homogeneous(1, 2, base_ring=QQ[&#39;t&#39;])</span>
<span class="sd">        h[1] + 2</span>

<span class="sd">        sage: dual_k_theoretic_homogeneous([2, 1], [1, 1])</span>
<span class="sd">        h[1]**2 + h[1]*h[2] + 2*h[1] + h[2] + 1</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`dual_k_catalan_function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="c1"># pad with 0&#39;s</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="c1"># multiply</span>
        <span class="n">h_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">dual_k_theoretic_homogeneous</span><span class="p">(</span>
            <span class="n">k_el</span><span class="p">,</span> <span class="n">r_el</span><span class="p">,</span> <span class="n">base_ring</span><span class="p">)</span> <span class="k">for</span> <span class="n">k_el</span><span class="p">,</span> <span class="n">r_el</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">h_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">binomial</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="dual_k_catalan_function"><a class="viewcode-back" href="../all.html#all.dual_k_catalan_function">[docs]</a><span class="k">def</span> <span class="nf">dual_k_catalan_function</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    INPUTS:</span>

<span class="sd">    - ``roots`` -- iterable of roots `\Phi` (typically a :class:`RootIdeal`)</span>

<span class="sd">    - ``index`` -- composition `\gamma` that indexes `h_\gamma(x; \alpha)`</span>

<span class="sd">    - ``index2`` -- composition `\alpha` used in `h_\gamma(x; \alpha)`</span>

<span class="sd">    OPTIONAL INPUTS:</span>

<span class="sd">    - ``base_ring`` -- (default ``QQ``) the ring over which to build the `h_\gamma(x; \alpha)`&#39;s</span>

<span class="sd">    OUTPUTS:</span>

<span class="sd">    The &#39;dual k&#39; catalan function</span>

<span class="sd">    ..  MATH::</span>

<span class="sd">        \prod_{ij \in \Delta^+ \smallsetminus \Phi} (1 - R_{ij}) h_\gamma(x; \alpha).</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`dual_k_theoretic_homogeneous`, :meth:`dual_grothendieck_function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># setup</span>
    <span class="n">Kh</span> <span class="o">=</span> <span class="n">dual_k_theoretic_homogeneous</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">)</span>
    <span class="c1"># formula</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="n">RootIdeal</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
    <span class="n">roots_complement</span> <span class="o">=</span> <span class="n">roots</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">raising_roots_operator</span><span class="p">(</span><span class="n">roots_complement</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cat_func</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">Kh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cat_func</span></div>


<div class="viewcode-block" id="dual_grothendieck_function"><a class="viewcode-back" href="../all.html#all.dual_grothendieck_function">[docs]</a><span class="k">def</span> <span class="nf">dual_grothendieck_function</span><span class="p">(</span><span class="n">composition</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a composition `composition = \lambda`, return the dual Grothendieck function defined by `g_\lambda(x) = \text{det}(h_{\lambda_i + j - i}(x, i - 1))` in [LN]_ p.88 equation (4).</span>

<span class="sd">    Equivalently, the dual Grothendieck function is `g_\lambda(x) = \prod_{ij \in \Delta^+} (1 - R_{ij}) h_\lambda(x; (0, 1, \ldots, n-1))`.</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: h = SymmetricFunctions(QQ).h()</span>
<span class="sd">        sage: dual_grothendieck_function([2, 1])</span>
<span class="sd">        h[1]*h[2] + h[2] - h[3]</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`dual_k_catalan_function`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># because dual_k_catalan_function will take the complement</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
    <span class="n">reversed_staircase_ptn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">staircase_shape</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">dual_k_catalan_function</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">composition</span><span class="p">,</span> <span class="n">reversed_staircase_ptn</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">base_ring</span><span class="p">)</span></div>


<div class="viewcode-block" id="double_homogeneous_building_block"><a class="viewcode-back" href="../all.html#all.double_homogeneous_building_block">[docs]</a><span class="k">def</span> <span class="nf">double_homogeneous_building_block</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The double complete homogeneous symmetric polynomial &quot;building block&quot; `h_p(x || a)`.</span>

<span class="sd">    Defined as</span>

<span class="sd">    ..  MATH::</span>
<span class="sd">        h_p(x_1, \ldots, x_n \,||\, a) \,= \sum_{n \geq i_1 \geq \ldots \geq i_p \geq 1} (x_{i_1} - a_{i_1})(x_{i_2} - a_{i_2 - 1}) \cdots (x_{i_p} - a_{i_p - p + 1})</span>

<span class="sd">    in [Fun]_ section 3 between equation (6) and (7).  Note that our indices are 0-based.</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :class:`DoubleHomogeneous`, :meth:`double_homogeneous_building_block_shifted`, :meth:`shift`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">DoubleRing</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">DoubleRing</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
    <span class="n">one_poly</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">one_poly</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="n">ptns</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="n">max_part</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ptn</span> <span class="ow">in</span> <span class="n">ptns</span><span class="p">:</span>
        <span class="n">summand</span> <span class="o">=</span> <span class="n">prod</span><span class="p">([(</span><span class="n">x</span><span class="p">[</span><span class="n">ptn</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">ptn</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)],</span> <span class="n">a</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
        <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">summand</span>
    <span class="k">return</span> <span class="n">total_sum</span></div>


<div class="viewcode-block" id="shift"><a class="viewcode-back" href="../all.html#all.shift">[docs]</a><span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The function `\tau` which acts on any element of `\Lambda(a)` (``DoubleRing``) by sending each element `a_i` to `a_{i+1}` for all `i`.  It can be found in [Fun]_ p.8 between equations (6) and (7).</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`double_homogeneous_building_block_shifted`, :meth:`double_homogeneous_building_block`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># idea, use .hom ``f = ZZ.hom(GF(3))``</span>
    <span class="c1"># sage: R.&lt;x&gt; = ZZ[]</span>
    <span class="c1"># sage: f = R.hom([x])</span>
    <span class="c1"># idea, define something on x[i] in general and take the induces hom</span>
    <span class="c1"># idea, manual</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">DoubleRing</span>
    <span class="n">new_monomials</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">element</span><span class="o">.</span><span class="n">monomialomial_coefficients</span><span class="p">():</span>
        <span class="n">new_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">monomial</span><span class="p">:</span>
            <span class="n">new_factor</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_factor</span><span class="p">)</span>
        <span class="n">new_monomial</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">prod</span><span class="p">(</span><span class="n">new_factors</span><span class="p">)</span>
        <span class="n">new_monomials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_monomial</span><span class="p">)</span>
    <span class="n">new_element</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_monomials</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_element</span></div>


<div class="viewcode-block" id="double_homogeneous_building_block_shifted"><a class="viewcode-back" href="../all.html#all.double_homogeneous_building_block_shifted">[docs]</a><span class="k">def</span> <span class="nf">double_homogeneous_building_block_shifted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given `r` and `s`, returns `h_{r, s} = \tau^s h_r(x \,||\, a)`, as defined in [Fun]_ before eq (8).</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :class:`DoubleHomogeneous`, :meth:`double_homogeneous_building_block`, :meth:`shift`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">double_homogeneous_building_block</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="DoubleHomogeneous"><a class="viewcode-back" href="../all.html#all.DoubleHomogeneous">[docs]</a><span class="k">class</span> <span class="nc">DoubleHomogeneous</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    INPUTS:</span>

<span class="sd">    ``mu1`` -- composition</span>

<span class="sd">    ``mu2`` -- composition</span>

<span class="sd">    ``n`` -- number of `x` variables</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">    Create the double homogeneous `h^{(4)}_{\mu, \beta}`::</span>

<span class="sd">        sage: DoubleHomogeneous(mu, beta, 4)</span>

<span class="sd">    Create the double homogeneous shifted building block `h_{r, s}` in 4 variables::</span>

<span class="sd">        sage: r = 5</span>
<span class="sd">        sage: s = 2</span>
<span class="sd">        sage: DoubleHomogeneous([r], [s], 4)</span>

<span class="sd">    Create the double homogeneous symmetric building block `h_p(x \,||\, a)` in 4 variables::</span>

<span class="sd">        sage: p = 3</span>
<span class="sd">        sage: DoubleHomogeneous([p], [0], 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index1</span> <span class="o">=</span> <span class="n">index1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index2</span> <span class="o">=</span> <span class="n">index2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; For example, h(n)[mu, beta], which represents `h^{(n)}_{\mu, \beta}`. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)[</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_indices_for_index_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        This method is defined so that an element of any :class:`ShiftingOperatorAlgebra` (such as a raising operator) can act on this double homogeneous function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pair</span>

    <span class="k">def</span> <span class="nf">_new_object_for_index_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal helper function.</span>

<span class="sd">        This method is defined so that an element of any :class:`ShiftingOperatorAlgebra` (such as a raising operator) can act on this double homogeneous function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_obj</span>

<div class="viewcode-block" id="DoubleHomogeneous.eval"><a class="viewcode-back" href="../all.html#all.DoubleHomogeneous.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given the number of variables ``n``, return ``self`` expanded in terms of the shifted double homogeneous building blocks `h_{r, s}`. &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">mu1</span><span class="p">,</span> <span class="n">mu2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index2</span><span class="p">)</span>
        <span class="c1"># pad with 0&#39;s</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mu1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu2</span><span class="p">))</span>
        <span class="n">mu1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mu1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu1</span><span class="p">))</span>
        <span class="n">mu2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mu2</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">mu2</span><span class="p">))</span>
        <span class="c1"># compute</span>
        <span class="n">h_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">double_homogeneous_shifted</span><span class="p">(</span>
            <span class="n">mu1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mu2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_len</span><span class="p">)]</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">h_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hp</span></div>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="double_schur"><a class="viewcode-back" href="../all.html#all.double_schur">[docs]</a><span class="k">def</span> <span class="nf">double_schur</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a composition ``index`` `= \lambda` and the number of variables `n`, return the double Schur function defined by</span>

<span class="sd">    ..  MATH::</span>
<span class="sd">        s_\lambda(x_1, \ldots, x_n \,||\, a) = \text{det}\left(h^{(n)}_{\lambda_i + i - j, j - 1}\right)</span>

<span class="sd">    or equivalently, defined by</span>

<span class="sd">    ..  MATH::</span>
<span class="sd">        s_\lambda(x_1, \ldots, x_n \,||\, a) = \prod_{ij \in \Delta^+(l)} (1 - R_{ij}) h^{(n)}_{\lambda, (0, \ldots, l-1)}</span>

<span class="sd">    where `l` is the length of `\lambda`, in [Fun]_ p.9 equation (9).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">raising_roots_operator</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">staircase_shape</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span>
    <span class="n">h_index</span> <span class="o">=</span> <span class="n">DoubleHomogeneous</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">h_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="double_catalan_function"><a class="viewcode-back" href="../all.html#all.double_catalan_function">[docs]</a><span class="k">def</span> <span class="nf">double_catalan_function</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given some ``roots`` (typically a :class:`RootIdeal`), an ``index``, and the something something of the double homemgeneous function ``n``, return the corresponding double catalan function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: test this</span>
    <span class="c1"># setup</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">staircase_shape</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span>
    <span class="n">h_index</span> <span class="o">=</span> <span class="n">DoubleHomogeneous</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="c1"># formula</span>
    <span class="n">roots_complement</span> <span class="o">=</span> <span class="n">root_ideal</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
    <span class="c1"># TODO: see what to pass in for base_ring in below line.</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">raising_roots_operator</span><span class="p">(</span><span class="n">roots_complement</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">cat_func</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">h_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cat_func</span></div>


<div class="viewcode-block" id="substitute"><a class="viewcode-back" href="../all.html#all.substitute">[docs]</a><span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a symmetric function ``f``, plug the inputted ``t`` and ``q`` values into it and return the resulting function.</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`SymmetricFunctionAlgebra_schur_with_category.element_class.plethysm`, :meth:`ungraded`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># a t value of &#39;None&#39; will leave t as-is.</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="n">base_ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">base_ring</span><span class="p">)</span>
    <span class="n">f_s</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">f_s</span><span class="o">.</span><span class="n">coefficients</span><span class="p">()</span>
    <span class="c1"># Necessary because otherwise coeffs and monomials don&#39;t line up</span>
    <span class="n">monomials</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">f_s</span><span class="o">.</span><span class="n">monomials</span><span class="p">())</span>
    <span class="n">specialized_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">]</span>
    <span class="n">combine</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specialized_coeffs</span><span class="p">,</span> <span class="n">monomials</span><span class="p">)</span>
    <span class="n">ungraded_f_s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">monom</span> <span class="k">for</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">monom</span><span class="p">)</span> <span class="ow">in</span> <span class="n">combine</span><span class="p">)</span>
    <span class="n">ungraded_f</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">ungraded_f_s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ungraded_f</span></div>


<div class="viewcode-block" id="ungraded"><a class="viewcode-back" href="../all.html#all.ungraded">[docs]</a><span class="k">def</span> <span class="nf">ungraded</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Given a symmetric function ``f``, return the result of plugging in `t = 1`.</span>

<span class="sd">    ..  SEEALSO::</span>
<span class="sd">        :meth:`substitute`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">substitute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  
    
      <a href="../../index.html"><img src="../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../index.html">k-Schur combinatorics for SageMath 0.1.4 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Matthew Lancellotti, George Seelinger, Jennifer Morse.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
  </body>
</html>